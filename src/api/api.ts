/* tslint:disable */
/* eslint-disable */
/**
 * api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Represents the request format for currency types in the API, enabling serialization and deserialization to/from lowercase strings.
 * @export
 * @enum {string}
 */

export const CurrencyRequest = {
    Euro: 'euro',
    Epicoin: 'epicoin'
} as const;

export type CurrencyRequest = typeof CurrencyRequest[keyof typeof CurrencyRequest];


/**
 * Represents the response format for currency types in the API, enabling serialization and deserialization to/from lowercase strings.
 * @export
 * @enum {string}
 */

export const CurrencyResponse = {
    Euro: 'euro',
    Epicoin: 'epicoin'
} as const;

export type CurrencyResponse = typeof CurrencyResponse[keyof typeof CurrencyResponse];


/**
 * Represents a request to editing an existing location, including necessary validation for name length and optional category.
 * @export
 * @interface EditLocationRequest
 */
export interface EditLocationRequest {
    /**
     * The category of the location, which may be optional.
     * @type {LocationCategoryRequest}
     * @memberof EditLocationRequest
     */
    'category'?: LocationCategoryRequest | null;
    /**
     * Optional field to disable or enable the product.
     * @type {boolean}
     * @memberof EditLocationRequest
     */
    'disabled'?: boolean | null;
    /**
     * The name of the location, subject to length validation.
     * @type {string}
     * @memberof EditLocationRequest
     */
    'name'?: string | null;
}


/**
 * Request structure for editing an existing product, allowing optional updates to fields.
 * @export
 * @interface EditProductRequest
 */
export interface EditProductRequest {
    /**
     * Optional field to disable or enable the product.
     * @type {boolean}
     * @memberof EditProductRequest
     */
    'disabled'?: boolean | null;
    /**
     * Display Order of the product inside of lists, 0 is last + default
     * @type {number}
     * @memberof EditProductRequest
     */
    'display_order'?: number | null;
    /**
     * Optional image URL or path, which can also be set to `None`.
     * @type {string}
     * @memberof EditProductRequest
     */
    'image'?: string | null;
    /**
     * Optional Inventree IPN, can be `None` if specified.
     * @type {string}
     * @memberof EditProductRequest
     */
    'inventree_code'?: string | null;
    /**
     * Optional maximum quantity per command with conversion and size limits.
     * @type {number}
     * @memberof EditProductRequest
     */
    'max_quantity_per_command'?: number | null;
    /**
     * Optional name of the product with length validation.
     * @type {string}
     * @memberof EditProductRequest
     */
    'name'?: string | null;
    /**
     * If the product is purchasable or if it\'s just an ingredients
     * @type {boolean}
     * @memberof EditProductRequest
     */
    'purchasable'?: boolean | null;
    /**
     * Optional price of the product, required to be positive if present.
     * @type {number}
     * @memberof EditProductRequest
     */
    'sell_price'?: number | null;
    /**
     * Optional price of the product, required to be positive if present.
     * @type {CurrencyRequest}
     * @memberof EditProductRequest
     */
    'sell_price_currency'?: CurrencyRequest | null;
    /**
     * Optional SMA code for product identification, can be `None` if specified.
     * @type {string}
     * @memberof EditProductRequest
     */
    'sma_code'?: string | null;
    /**
     * Represent the unit type of Product, if it\'s a liquid -> Liter, etc..., the default is Unit
     * @type {UnitRequest}
     * @memberof EditProductRequest
     */
    'unit'?: UnitRequest | null;
}


/**
 * Structure representing a request to edit an existing refill entry.
 * @export
 * @interface EditRefillRequest
 */
export interface EditRefillRequest {
    /**
     * Optional new amount for the refill.
     * @type {number}
     * @memberof EditRefillRequest
     */
    'credit'?: number | null;
    /**
     * Optional currency type for the new refill credit.
     * @type {CurrencyRequest}
     * @memberof EditRefillRequest
     */
    'credit_currency'?: CurrencyRequest | null;
    /**
     * Optional new disabled status for the refill.
     * @type {boolean}
     * @memberof EditRefillRequest
     */
    'disabled'?: boolean | null;
    /**
     * Optional new name for the refill.
     * @type {string}
     * @memberof EditRefillRequest
     */
    'name'?: string | null;
    /**
     * Optional new amount for the refill.
     * @type {number}
     * @memberof EditRefillRequest
     */
    'price'?: number | null;
    /**
     * Optional currency type for the new refill price.
     * @type {CurrencyRequest}
     * @memberof EditRefillRequest
     */
    'price_currency'?: CurrencyRequest | null;
}


/**
 * Represents an update request for user-specific fields, allowing modification of key boolean attributes such as `is_admin` and `is_banned`.
 * @export
 * @interface EditUserRequest
 */
export interface EditUserRequest {
    /**
     * Indicates whether the user has admin privileges.
     * @type {boolean}
     * @memberof EditUserRequest
     */
    'is_admin'?: boolean | null;
    /**
     * Indicates whether the user is banned from the system.
     * @type {boolean}
     * @memberof EditUserRequest
     */
    'is_banned'?: boolean | null;
}
/**
 * Response structure for edited product details.
 * @export
 * @interface EditedProductResponse
 */
export interface EditedProductResponse {
    /**
     * Optional flag indicating if the product is disabled.
     * @type {boolean}
     * @memberof EditedProductResponse
     */
    'disabled'?: boolean | null;
    /**
     * Unique identifier for the product.
     * @type {string}
     * @memberof EditedProductResponse
     */
    'id': string;
    /**
     * Optional image associated with the product.
     * @type {string}
     * @memberof EditedProductResponse
     */
    'image'?: string | null;
    /**
     * Optional maximum quantity allowed per command.
     * @type {number}
     * @memberof EditedProductResponse
     */
    'max_quantity_per_command'?: number | null;
    /**
     * Optional name of the product.
     * @type {string}
     * @memberof EditedProductResponse
     */
    'name'?: string | null;
    /**
     * Optional price of the product.
     * @type {number}
     * @memberof EditedProductResponse
     */
    'price'?: number | null;
    /**
     * Optional SMA code associated with the product.
     * @type {string}
     * @memberof EditedProductResponse
     */
    'sma_code'?: string | null;
}
/**
 * Represents a standardized error response returned by the API.  This struct is designed to provide structured error information to clients, including an HTTP status code, an error identifier, a category describing the error type, and a user-friendly error message.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * A brief string identifying the type of error.
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
    /**
     * The category or kind of the error, often used to classify error types.
     * @type {string}
     * @memberof ErrorResponse
     */
    'kind': string;
    /**
     * A descriptive message providing additional details about the error.
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * The HTTP status code associated with the error.
     * @type {number}
     * @memberof ErrorResponse
     */
    'status': number;
}
/**
 * Enum representing the different types of files.  This enum is used to differentiate between various types of file. It is deserialized from lowercase string values.
 * @export
 * @enum {string}
 */

export const FileType = {
    Product: 'product'
} as const;

export type FileType = typeof FileType[keyof typeof FileType];


/**
 * Enum representing categories of locations, such as dispensers or rooms. This type is used for deserializing request payloads.
 * @export
 * @enum {string}
 */

export const LocationCategoryRequest = {
    Dispenser: 'dispenser',
    Room: 'room'
} as const;

export type LocationCategoryRequest = typeof LocationCategoryRequest[keyof typeof LocationCategoryRequest];


/**
 * Enum representing categories of locations, such as dispensers or rooms. This type is used for serializing request payloads and indicates the type of location being referred to in a response.
 * @export
 * @enum {string}
 */

export const LocationCategoryResponse = {
    Dispenser: 'dispenser',
    Room: 'room'
} as const;

export type LocationCategoryResponse = typeof LocationCategoryResponse[keyof typeof LocationCategoryResponse];


/**
 * Response structure representing a paginated list of locations.  This structure is intended for use in API responses where a paginated list of locations is required.
 * @export
 * @interface LocationListResponse
 */
export interface LocationListResponse {
    /**
     * The current page number in the paginated response.
     * @type {number}
     * @memberof LocationListResponse
     */
    'current_page': number;
    /**
     * A list of locations on the current page, represented by `LocationResponse`.
     * @type {Array<LocationResponse>}
     * @memberof LocationListResponse
     */
    'locations': Array<LocationResponse>;
    /**
     * The total number of pages available.
     * @type {number}
     * @memberof LocationListResponse
     */
    'total_page': number;
}
/**
 * Response structure representing a location entity, including its unique identifier, name, category, creation timestamp, and status.  This structure is used for API responses where individual location details are required.
 * @export
 * @interface LocationResponse
 */
export interface LocationResponse {
    /**
     * The category of the location, which could be `Dispenser` or `Room`.
     * @type {LocationCategoryResponse}
     * @memberof LocationResponse
     */
    'category'?: LocationCategoryResponse | null;
    /**
     * The timestamp indicating when the location was created.
     * @type {string}
     * @memberof LocationResponse
     */
    'created_at': string;
    /**
     * Indicates whether the location is disabled.
     * @type {boolean}
     * @memberof LocationResponse
     */
    'disabled': boolean;
    /**
     * Unique identifier of the location.
     * @type {string}
     * @memberof LocationResponse
     */
    'id': string;
    /**
     * The name of the location.
     * @type {string}
     * @memberof LocationResponse
     */
    'name': string;
}


/**
 * Generated by DeriveToSortQuery macro for flo_orm
 * @export
 * @enum {string}
 */

export const LocationSortEnum = {
    IdAsc: 'id_asc',
    IdDesc: 'id_desc',
    NameAsc: 'name_asc',
    NameDesc: 'name_desc',
    CreatedAtAsc: 'created_at_asc',
    CreatedAtDesc: 'created_at_desc',
    CategoryAsc: 'category_asc',
    CategoryDesc: 'category_desc',
    DisabledAsc: 'disabled_asc',
    DisabledDesc: 'disabled_desc'
} as const;

export type LocationSortEnum = typeof LocationSortEnum[keyof typeof LocationSortEnum];


/**
 * Represents a request to create a new location, including necessary validation for name length and optional category.
 * @export
 * @interface NewLocationRequest
 */
export interface NewLocationRequest {
    /**
     * The category of the location, which may be optional.
     * @type {LocationCategoryRequest}
     * @memberof NewLocationRequest
     */
    'category'?: LocationCategoryRequest | null;
    /**
     * The name of the location, subject to length validation.
     * @type {string}
     * @memberof NewLocationRequest
     */
    'name': string;
}


/**
 * Request structure for creating a new product, including validation rules.
 * @export
 * @interface NewProductRequest
 */
export interface NewProductRequest {
    /**
     * Optional image URL or path.
     * @type {string}
     * @memberof NewProductRequest
     */
    'image'?: string | null;
    /**
     * Optional Inventree IPN
     * @type {string}
     * @memberof NewProductRequest
     */
    'inventree_code'?: string | null;
    /**
     * Optional maximum quantity per command, limited to a certain maximum.
     * @type {number}
     * @memberof NewProductRequest
     */
    'max_quantity_per_command'?: number | null;
    /**
     * Name of the product, required and validated for length.
     * @type {string}
     * @memberof NewProductRequest
     */
    'name': string;
    /**
     * If the product is purchasable or if it\'s just an ingredients
     * @type {boolean}
     * @memberof NewProductRequest
     */
    'purchasable'?: boolean | null;
    /**
     * Price of the product, required and must be positive.
     * @type {number}
     * @memberof NewProductRequest
     */
    'sell_price': number;
    /**
     * Currency of the product.
     * @type {CurrencyRequest}
     * @memberof NewProductRequest
     */
    'sell_price_currency': CurrencyRequest;
    /**
     * Optional SMA code for product identification.
     * @type {string}
     * @memberof NewProductRequest
     */
    'sma_code'?: string | null;
    /**
     * Represent the unit type of Product, if it\'s a liquid -> Liter, etc..., the default is Unit
     * @type {UnitRequest}
     * @memberof NewProductRequest
     */
    'unit'?: UnitRequest | null;
}


/**
 * Request structure for creating a new refill, including validation rules.
 * @export
 * @interface NewRefillRequest
 */
export interface NewRefillRequest {
    /**
     * Amount given with refill
     * @type {number}
     * @memberof NewRefillRequest
     */
    'credit': number;
    /**
     * Currency type for the refill credit.
     * @type {CurrencyRequest}
     * @memberof NewRefillRequest
     */
    'credit_currency': CurrencyRequest;
    /**
     * Name of the refill, required and validated for length.
     * @type {string}
     * @memberof NewRefillRequest
     */
    'name'?: string | null;
    /**
     * Amount for buying refill
     * @type {number}
     * @memberof NewRefillRequest
     */
    'price': number;
    /**
     * Currency type for the refill price.
     * @type {CurrencyRequest}
     * @memberof NewRefillRequest
     */
    'price_currency': CurrencyRequest;
}


/**
 * Response structure for a list of products with pagination details.
 * @export
 * @interface ProductListResponse
 */
export interface ProductListResponse {
    /**
     * Current page number.
     * @type {number}
     * @memberof ProductListResponse
     */
    'current_page': number;
    /**
     * List of products on the current page.
     * @type {Array<ProductResponse>}
     * @memberof ProductListResponse
     */
    'products': Array<ProductResponse>;
    /**
     * Total number of pages available.
     * @type {number}
     * @memberof ProductListResponse
     */
    'total_page': number;
}
/**
 * Response structure for a product, including its details.
 * @export
 * @interface ProductResponse
 */
export interface ProductResponse {
    /**
     * Creation timestamp of the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'created_at': string;
    /**
     * Optional flag indicating if the product is disabled.
     * @type {boolean}
     * @memberof ProductResponse
     */
    'disabled'?: boolean | null;
    /**
     * Display Order of the product.
     * @type {number}
     * @memberof ProductResponse
     */
    'display_order': number;
    /**
     * Unique identifier for the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'id': string;
    /**
     * Optional image associated with the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'image'?: string | null;
    /**
     * Optional Inventree IPN
     * @type {string}
     * @memberof ProductResponse
     */
    'inventree_code'?: string | null;
    /**
     * Optional maximum quantity allowed per command.
     * @type {number}
     * @memberof ProductResponse
     */
    'max_quantity_per_command'?: number | null;
    /**
     * Name of the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'name': string;
    /**
     * Is the product purchasable
     * @type {boolean}
     * @memberof ProductResponse
     */
    'purchasable': boolean;
    /**
     * Price of the product.
     * @type {number}
     * @memberof ProductResponse
     */
    'sell_price': number;
    /**
     * Currency of the product price.
     * @type {CurrencyResponse}
     * @memberof ProductResponse
     */
    'sell_price_currency': CurrencyResponse;
    /**
     * Optional SMA code associated with the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'sma_code'?: string | null;
    /**
     * Represent the unit type of Product, if it\'s a liquid -> Liter, etc...
     * @type {UnitResponse}
     * @memberof ProductResponse
     */
    'unit': UnitResponse;
}


/**
 * Generated by DeriveToSortQuery macro for flo_orm
 * @export
 * @enum {string}
 */

export const ProductSortEnum = {
    IdAsc: 'id_asc',
    IdDesc: 'id_desc',
    ImageAsc: 'image_asc',
    ImageDesc: 'image_desc',
    NameAsc: 'name_asc',
    NameDesc: 'name_desc',
    DisplayOrderAsc: 'display_order_asc',
    DisplayOrderDesc: 'display_order_desc',
    SellPriceAsc: 'sell_price_asc',
    SellPriceDesc: 'sell_price_desc',
    SellPriceCurrencyAsc: 'sell_price_currency_asc',
    SellPriceCurrencyDesc: 'sell_price_currency_desc',
    PurchasableAsc: 'purchasable_asc',
    PurchasableDesc: 'purchasable_desc',
    UnitAsc: 'unit_asc',
    UnitDesc: 'unit_desc',
    MaxQuantityPerCommandAsc: 'max_quantity_per_command_asc',
    MaxQuantityPerCommandDesc: 'max_quantity_per_command_desc',
    DisabledAsc: 'disabled_asc',
    DisabledDesc: 'disabled_desc',
    CreatedAtAsc: 'created_at_asc',
    CreatedAtDesc: 'created_at_desc',
    SmaCodeAsc: 'sma_code_asc',
    SmaCodeDesc: 'sma_code_desc',
    InventreeCodeAsc: 'inventree_code_asc',
    InventreeCodeDesc: 'inventree_code_desc'
} as const;

export type ProductSortEnum = typeof ProductSortEnum[keyof typeof ProductSortEnum];


/**
 * Represents a response containing a list of refills returned by the API.
 * @export
 * @interface RefillListResponse
 */
export interface RefillListResponse {
    /**
     * The current page number being viewed.
     * @type {number}
     * @memberof RefillListResponse
     */
    'current_page': number;
    /**
     * A list of refill responses containing refill details.
     * @type {Array<RefillResponse>}
     * @memberof RefillListResponse
     */
    'refills': Array<RefillResponse>;
    /**
     * The total number of pages available for refill results.
     * @type {number}
     * @memberof RefillListResponse
     */
    'total_page': number;
}
/**
 * Represents a response containing refill information returned by the API.
 * @export
 * @interface RefillResponse
 */
export interface RefillResponse {
    /**
     * The timestamp indicating when the refill was created.
     * @type {string}
     * @memberof RefillResponse
     */
    'created_at': string;
    /**
     * Credit of the refill.
     * @type {number}
     * @memberof RefillResponse
     */
    'credit': number;
    /**
     * Currency type for the refill credit.
     * @type {CurrencyResponse}
     * @memberof RefillResponse
     */
    'credit_currency': CurrencyResponse;
    /**
     * Indicates whether the refill is currently disabled.
     * @type {boolean}
     * @memberof RefillResponse
     */
    'disabled': boolean;
    /**
     * Unique identifier for the refill.
     * @type {string}
     * @memberof RefillResponse
     */
    'id': string;
    /**
     * The full name of the refill.
     * @type {string}
     * @memberof RefillResponse
     */
    'name'?: string | null;
    /**
     * Price of the refill.
     * @type {number}
     * @memberof RefillResponse
     */
    'price': number;
    /**
     * Currency type for the refill price.
     * @type {CurrencyResponse}
     * @memberof RefillResponse
     */
    'price_currency': CurrencyResponse;
}


/**
 * Generated by DeriveToSortQuery macro for flo_orm
 * @export
 * @enum {string}
 */

export const RefillSortEnum = {
    IdAsc: 'id_asc',
    IdDesc: 'id_desc',
    NameAsc: 'name_asc',
    NameDesc: 'name_desc',
    CreatedAtAsc: 'created_at_asc',
    CreatedAtDesc: 'created_at_desc',
    PriceAsc: 'price_asc',
    PriceDesc: 'price_desc',
    PriceCurrencyAsc: 'price_currency_asc',
    PriceCurrencyDesc: 'price_currency_desc',
    CreditAsc: 'credit_asc',
    CreditDesc: 'credit_desc',
    CreditCurrencyAsc: 'credit_currency_asc',
    CreditCurrencyDesc: 'credit_currency_desc',
    DisabledAsc: 'disabled_asc',
    DisabledDesc: 'disabled_desc'
} as const;

export type RefillSortEnum = typeof RefillSortEnum[keyof typeof RefillSortEnum];


/**
 * Represents the response structure for synchronizing products with the SMA system, categorizing products based on their synchronization status. This structure is intended for use in API responses where the status of products in relation to the SMA system needs to be clearly distinguished.
 * @export
 * @interface SmaResponse
 */
export interface SmaResponse {
    /**
     * A list of products that were updated, represented by `EditedProductResponse`.
     * @type {Array<EditedProductResponse>}
     * @memberof SmaResponse
     */
    'changed': Array<EditedProductResponse>;
    /**
     * A list of newly created products, represented by `ProductResponse`.
     * @type {Array<ProductResponse>}
     * @memberof SmaResponse
     */
    'created': Array<ProductResponse>;
    /**
     * A list of product IDs that have not been modified during the synchronization process.
     * @type {Array<string>}
     * @memberof SmaResponse
     */
    'unchanged': Array<string>;
}
/**
 * Represents the different type of Unit an Product or Else can have
 * @export
 * @enum {string}
 */

export const UnitRequest = {
    Unit: 'unit',
    Gram: 'gram',
    Liter: 'liter',
    Meter: 'meter'
} as const;

export type UnitRequest = typeof UnitRequest[keyof typeof UnitRequest];


/**
 * Represents the different type of Unit an Product or Else can have
 * @export
 * @enum {string}
 */

export const UnitResponse = {
    Unit: 'unit',
    Gram: 'gram',
    Liter: 'liter',
    Meter: 'meter'
} as const;

export type UnitResponse = typeof UnitResponse[keyof typeof UnitResponse];


/**
 * Represents a response containing a list of users returned by the API.
 * @export
 * @interface UserListResponse
 */
export interface UserListResponse {
    /**
     * The current page number being viewed.
     * @type {number}
     * @memberof UserListResponse
     */
    'current_page': number;
    /**
     * The total number of pages available for user results.
     * @type {number}
     * @memberof UserListResponse
     */
    'total_page': number;
    /**
     * A list of user responses containing user details.
     * @type {Array<UserResponse>}
     * @memberof UserListResponse
     */
    'users': Array<UserResponse>;
}
/**
 * Represents a response containing user information returned by the API.
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * The timestamp of when the user was created.
     * @type {string}
     * @memberof UserResponse
     */
    'created_at': string;
    /**
     * The email address of the user.
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string | null;
    /**
     * Unique identifier for the user.
     * @type {string}
     * @memberof UserResponse
     */
    'id': string;
    /**
     * Indicates whether the user has admin privileges.
     * @type {boolean}
     * @memberof UserResponse
     */
    'is_admin': boolean;
    /**
     * Indicates whether the user is banned from the application.
     * @type {boolean}
     * @memberof UserResponse
     */
    'is_banned': boolean;
    /**
     * The timestamp of the user\'s last access.
     * @type {string}
     * @memberof UserResponse
     */
    'last_access_at': string;
    /**
     * The full name of the user.
     * @type {string}
     * @memberof UserResponse
     */
    'name'?: string | null;
    /**
     * The username chosen by the user.
     * @type {string}
     * @memberof UserResponse
     */
    'username'?: string | null;
}
/**
 * Generated by DeriveToSortQuery macro for flo_orm
 * @export
 * @enum {string}
 */

export const UserSortEnum = {
    IdAsc: 'id_asc',
    IdDesc: 'id_desc',
    EmailAsc: 'email_asc',
    EmailDesc: 'email_desc',
    NameAsc: 'name_asc',
    NameDesc: 'name_desc',
    UsernameAsc: 'username_asc',
    UsernameDesc: 'username_desc',
    BalanceAsc: 'balance_asc',
    BalanceDesc: 'balance_desc',
    BalanceCurrencyAsc: 'balance_currency_asc',
    BalanceCurrencyDesc: 'balance_currency_desc',
    IsAdminAsc: 'is_admin_asc',
    IsAdminDesc: 'is_admin_desc',
    IsBannedAsc: 'is_banned_asc',
    IsBannedDesc: 'is_banned_desc',
    CreatedAtAsc: 'created_at_asc',
    CreatedAtDesc: 'created_at_desc',
    LastAccessAtAsc: 'last_access_at_asc',
    LastAccessAtDesc: 'last_access_at_desc'
} as const;

export type UserSortEnum = typeof UserSortEnum[keyof typeof UserSortEnum];



/**
 * LocationApi - axios parameter creator
 * @export
 */
export const LocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The location is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the location in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The location has been successfully disabled.
         * @summary Deletes a location by its database ID.
         * @param {string} id Location database id to delete location for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLocation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLocation', 'id', id)
            const localVarPath = `/location/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an error if the location doesn\'t exist, if there is a validation issue, or if a database.
         * @summary Edit an existing location by ID.
         * @param {string} id location database id to edit location for
         * @param {EditLocationRequest} editLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLocation: async (id: string, editLocationRequest: EditLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editLocation', 'id', id)
            // verify required parameter 'editLocationRequest' is not null or undefined
            assertParamExists('editLocation', 'editLocationRequest', editLocationRequest)
            const localVarPath = `/location/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of location per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of locations.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view disabled location
         * @summary Handles the request to retrieve a paginated list of locations.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<LocationCategoryRequest>} [categoryEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<LocationCategoryRequest>} [categoryNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<LocationSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLocations: async (page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, categoryEq?: Array<LocationCategoryRequest>, categoryNeq?: Array<LocationCategoryRequest>, disabledEq?: boolean | null, disabledNeq?: boolean | null, sort?: Array<LocationSortEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (idEq) {
                localVarQueryParameter['id_eq'] = idEq;
            }

            if (idNeq) {
                localVarQueryParameter['id_neq'] = idNeq;
            }

            if (nameEq) {
                localVarQueryParameter['name_eq'] = nameEq;
            }

            if (nameNeq) {
                localVarQueryParameter['name_neq'] = nameNeq;
            }

            if (createdAtEq) {
                localVarQueryParameter['created_at_eq'] = createdAtEq;
            }

            if (createdAtNeq) {
                localVarQueryParameter['created_at_neq'] = createdAtNeq;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString() :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString() :
                    createdAtLt;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (categoryEq) {
                localVarQueryParameter['category_eq'] = categoryEq;
            }

            if (categoryNeq) {
                localVarQueryParameter['category_neq'] = categoryNeq;
            }

            if (disabledEq !== undefined) {
                localVarQueryParameter['disabled_eq'] = disabledEq;
            }

            if (disabledNeq !== undefined) {
                localVarQueryParameter['disabled_neq'] = disabledNeq;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the location to retrieve.  - **Response Codes**:   - `200 OK`: The location was successfully retrieved.   - `404 Not Found`: The location doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the location is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a location by its unique identifier.
         * @param {string} id The database ID of the location to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLocation', 'id', id)
            const localVarPath = `/location/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function allows an admin to create a new location by sending a POST request to the `/location` endpoint. The new location is validated and stored in the database. The image associated with the location is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the location\'s ID.  Path: `/location`  - **Request Body:** Expects a `NewLocation` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new location, returns the new location\'s ID as a string.
         * @summary Handler for creating a new location.
         * @param {NewLocationRequest} newLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewLocation: async (newLocationRequest: NewLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newLocationRequest' is not null or undefined
            assertParamExists('postNewLocation', 'newLocationRequest', newLocationRequest)
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationApi - functional programming interface
 * @export
 */
export const LocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationApiAxiosParamCreator(configuration)
    return {
        /**
         * The location is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the location in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The location has been successfully disabled.
         * @summary Deletes a location by its database ID.
         * @param {string} id Location database id to delete location for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLocation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLocation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.deleteLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an error if the location doesn\'t exist, if there is a validation issue, or if a database.
         * @summary Edit an existing location by ID.
         * @param {string} id location database id to edit location for
         * @param {EditLocationRequest} editLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editLocation(id: string, editLocationRequest: EditLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editLocation(id, editLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.editLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of location per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of locations.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view disabled location
         * @summary Handles the request to retrieve a paginated list of locations.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<LocationCategoryRequest>} [categoryEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<LocationCategoryRequest>} [categoryNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<LocationSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllLocations(page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, categoryEq?: Array<LocationCategoryRequest>, categoryNeq?: Array<LocationCategoryRequest>, disabledEq?: boolean | null, disabledNeq?: boolean | null, sort?: Array<LocationSortEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllLocations(page, perPage, idEq, idNeq, nameEq, nameNeq, createdAtEq, createdAtNeq, createdAtGt, createdAtLt, createdAtGte, createdAtLte, categoryEq, categoryNeq, disabledEq, disabledNeq, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.getAllLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the location to retrieve.  - **Response Codes**:   - `200 OK`: The location was successfully retrieved.   - `404 Not Found`: The location doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the location is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a location by its unique identifier.
         * @param {string} id The database ID of the location to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.getLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function allows an admin to create a new location by sending a POST request to the `/location` endpoint. The new location is validated and stored in the database. The image associated with the location is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the location\'s ID.  Path: `/location`  - **Request Body:** Expects a `NewLocation` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new location, returns the new location\'s ID as a string.
         * @summary Handler for creating a new location.
         * @param {NewLocationRequest} newLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNewLocation(newLocationRequest: NewLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNewLocation(newLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.postNewLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationApi - factory interface
 * @export
 */
export const LocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationApiFp(configuration)
    return {
        /**
         * The location is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the location in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The location has been successfully disabled.
         * @summary Deletes a location by its database ID.
         * @param {LocationApiDeleteLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLocation(requestParameters: LocationApiDeleteLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteLocation(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an error if the location doesn\'t exist, if there is a validation issue, or if a database.
         * @summary Edit an existing location by ID.
         * @param {LocationApiEditLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLocation(requestParameters: LocationApiEditLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editLocation(requestParameters.id, requestParameters.editLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of location per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of locations.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view disabled location
         * @summary Handles the request to retrieve a paginated list of locations.
         * @param {LocationApiGetAllLocationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLocations(requestParameters: LocationApiGetAllLocationsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<LocationListResponse> {
            return localVarFp.getAllLocations(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.categoryEq, requestParameters.categoryNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the location to retrieve.  - **Response Codes**:   - `200 OK`: The location was successfully retrieved.   - `404 Not Found`: The location doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the location is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a location by its unique identifier.
         * @param {LocationApiGetLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocation(requestParameters: LocationApiGetLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationResponse> {
            return localVarFp.getLocation(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This function allows an admin to create a new location by sending a POST request to the `/location` endpoint. The new location is validated and stored in the database. The image associated with the location is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the location\'s ID.  Path: `/location`  - **Request Body:** Expects a `NewLocation` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new location, returns the new location\'s ID as a string.
         * @summary Handler for creating a new location.
         * @param {LocationApiPostNewLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewLocation(requestParameters: LocationApiPostNewLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postNewLocation(requestParameters.newLocationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteLocation operation in LocationApi.
 * @export
 * @interface LocationApiDeleteLocationRequest
 */
export interface LocationApiDeleteLocationRequest {
    /**
     * Location database id to delete location for
     * @type {string}
     * @memberof LocationApiDeleteLocation
     */
    readonly id: string
}

/**
 * Request parameters for editLocation operation in LocationApi.
 * @export
 * @interface LocationApiEditLocationRequest
 */
export interface LocationApiEditLocationRequest {
    /**
     * location database id to edit location for
     * @type {string}
     * @memberof LocationApiEditLocation
     */
    readonly id: string

    /**
     * 
     * @type {EditLocationRequest}
     * @memberof LocationApiEditLocation
     */
    readonly editLocationRequest: EditLocationRequest
}

/**
 * Request parameters for getAllLocations operation in LocationApi.
 * @export
 * @interface LocationApiGetAllLocationsRequest
 */
export interface LocationApiGetAllLocationsRequest {
    /**
     * The page number to retrieve, starting from 0.
     * @type {number}
     * @memberof LocationApiGetAllLocations
     */
    readonly page?: number | null

    /**
     * The number of items to return per page.
     * @type {number}
     * @memberof LocationApiGetAllLocations
     */
    readonly perPage?: number | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof LocationApiGetAllLocations
     */
    readonly idEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof LocationApiGetAllLocations
     */
    readonly idNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof LocationApiGetAllLocations
     */
    readonly nameEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof LocationApiGetAllLocations
     */
    readonly nameNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof LocationApiGetAllLocations
     */
    readonly createdAtEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof LocationApiGetAllLocations
     */
    readonly createdAtNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof LocationApiGetAllLocations
     */
    readonly createdAtGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof LocationApiGetAllLocations
     */
    readonly createdAtLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof LocationApiGetAllLocations
     */
    readonly createdAtGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof LocationApiGetAllLocations
     */
    readonly createdAtLte?: string | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<LocationCategoryRequest>}
     * @memberof LocationApiGetAllLocations
     */
    readonly categoryEq?: Array<LocationCategoryRequest>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<LocationCategoryRequest>}
     * @memberof LocationApiGetAllLocations
     */
    readonly categoryNeq?: Array<LocationCategoryRequest>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof LocationApiGetAllLocations
     */
    readonly disabledEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof LocationApiGetAllLocations
     */
    readonly disabledNeq?: boolean | null

    /**
     * Used for sorting the output
     * @type {Array<LocationSortEnum>}
     * @memberof LocationApiGetAllLocations
     */
    readonly sort?: Array<LocationSortEnum>
}

/**
 * Request parameters for getLocation operation in LocationApi.
 * @export
 * @interface LocationApiGetLocationRequest
 */
export interface LocationApiGetLocationRequest {
    /**
     * The database ID of the location to retrieve.
     * @type {string}
     * @memberof LocationApiGetLocation
     */
    readonly id: string
}

/**
 * Request parameters for postNewLocation operation in LocationApi.
 * @export
 * @interface LocationApiPostNewLocationRequest
 */
export interface LocationApiPostNewLocationRequest {
    /**
     * 
     * @type {NewLocationRequest}
     * @memberof LocationApiPostNewLocation
     */
    readonly newLocationRequest: NewLocationRequest
}

/**
 * LocationApi - object-oriented interface
 * @export
 * @class LocationApi
 * @extends {BaseAPI}
 */
export class LocationApi extends BaseAPI {
    /**
     * The location is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the location in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The location has been successfully disabled.
     * @summary Deletes a location by its database ID.
     * @param {LocationApiDeleteLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public deleteLocation(requestParameters: LocationApiDeleteLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).deleteLocation(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an error if the location doesn\'t exist, if there is a validation issue, or if a database.
     * @summary Edit an existing location by ID.
     * @param {LocationApiEditLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public editLocation(requestParameters: LocationApiEditLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).editLocation(requestParameters.id, requestParameters.editLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of location per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of locations.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view disabled location
     * @summary Handles the request to retrieve a paginated list of locations.
     * @param {LocationApiGetAllLocationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public getAllLocations(requestParameters: LocationApiGetAllLocationsRequest = {}, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).getAllLocations(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.categoryEq, requestParameters.categoryNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Path Parameters**:   `id` (UUID): The database ID of the location to retrieve.  - **Response Codes**:   - `200 OK`: The location was successfully retrieved.   - `404 Not Found`: The location doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the location is disabled, only an admin can retrieve it.
     * @summary Handles the request to fetch a location by its unique identifier.
     * @param {LocationApiGetLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public getLocation(requestParameters: LocationApiGetLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).getLocation(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function allows an admin to create a new location by sending a POST request to the `/location` endpoint. The new location is validated and stored in the database. The image associated with the location is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the location\'s ID.  Path: `/location`  - **Request Body:** Expects a `NewLocation` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new location, returns the new location\'s ID as a string.
     * @summary Handler for creating a new location.
     * @param {LocationApiPostNewLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public postNewLocation(requestParameters: LocationApiPostNewLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).postNewLocation(requestParameters.newLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MiscApi - axios parameter creator
 * @export
 */
export const MiscApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This function retrieves a specified file based on the given filename and type, and streams it to the client. It also handles errors related to file access, returning appropriate HTTP status codes for various scenarios such as file not found or other errors.  # Parameters - `filename`: The name of the file to be downloaded. - `params`: The type of the file, which affects the download behavior.  # Responses - `200`: The file is correctly uploaded. - `400`: You\'re missing some field.  # Errors Returns an error if the file does not exist or if there is an issue with the S3 storage.
         * @summary Downloads files from the server\'s storage.
         * @param {string} filename The filename
         * @param {FileType} fileType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (filename: string, fileType: FileType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('downloadFile', 'filename', filename)
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('downloadFile', 'fileType', fileType)
            const localVarPath = `/download/{filename}`
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fileType !== undefined) {
                localVarQueryParameter['file_type'] = fileType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This asynchronous function handles the `/status` endpoint and returns a static string indicating that the server is running. It is commonly used for health checks to confirm that the application is up and operational.  # Returns A static string `\"UP\"`, representing the server\'s status.  # Endpoint - **GET /status**: Responds with `\"UP\"` and a `200 OK` status.
         * @summary Returns the status of the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Errors - Returns a 500 status code if there is an internal error, such as a failure to fetch or process Sma data. - Returns a 400 status code if the request to Sma is not correctly formatted.  # Responses - 200: The products have been successfully updated.
         * @summary Updates the local product database by importing products from the Sma API. This function retrieves the latest products from Sma, processes the data, and updates the local products accordingly.
         * @param {boolean} [name] Indicates if the product\&#39;s name has changed.
         * @param {boolean} [price] Indicates if the product\&#39;s price has changed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdateFromSma: async (name?: boolean, price?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sma`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows an admin user to upload files to a specified S3 bucket. It uses multipart form data to handle file uploads and stores them in a temporary S3 directory.
         * @summary Upload files
         * @param {FileType} fileType 
         * @param {File} file Represents the file data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUploadFiles: async (fileType: FileType, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('postUploadFiles', 'fileType', fileType)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('postUploadFiles', 'file', file)
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication axum-oidc required

            if (fileType !== undefined) {
                localVarQueryParameter['file_type'] = fileType;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscApi - functional programming interface
 * @export
 */
export const MiscApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscApiAxiosParamCreator(configuration)
    return {
        /**
         * This function retrieves a specified file based on the given filename and type, and streams it to the client. It also handles errors related to file access, returning appropriate HTTP status codes for various scenarios such as file not found or other errors.  # Parameters - `filename`: The name of the file to be downloaded. - `params`: The type of the file, which affects the download behavior.  # Responses - `200`: The file is correctly uploaded. - `400`: You\'re missing some field.  # Errors Returns an error if the file does not exist or if there is an issue with the S3 storage.
         * @summary Downloads files from the server\'s storage.
         * @param {string} filename The filename
         * @param {FileType} fileType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(filename: string, fileType: FileType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(filename, fileType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.downloadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This asynchronous function handles the `/status` endpoint and returns a static string indicating that the server is running. It is commonly used for health checks to confirm that the application is up and operational.  # Returns A static string `\"UP\"`, representing the server\'s status.  # Endpoint - **GET /status**: Responds with `\"UP\"` and a `200 OK` status.
         * @summary Returns the status of the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.getStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * # Errors - Returns a 500 status code if there is an internal error, such as a failure to fetch or process Sma data. - Returns a 400 status code if the request to Sma is not correctly formatted.  # Responses - 200: The products have been successfully updated.
         * @summary Updates the local product database by importing products from the Sma API. This function retrieves the latest products from Sma, processes the data, and updates the local products accordingly.
         * @param {boolean} [name] Indicates if the product\&#39;s name has changed.
         * @param {boolean} [price] Indicates if the product\&#39;s price has changed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdateFromSma(name?: boolean, price?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUpdateFromSma(name, price, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.postUpdateFromSma']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows an admin user to upload files to a specified S3 bucket. It uses multipart form data to handle file uploads and stores them in a temporary S3 directory.
         * @summary Upload files
         * @param {FileType} fileType 
         * @param {File} file Represents the file data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUploadFiles(fileType: FileType, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUploadFiles(fileType, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.postUploadFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MiscApi - factory interface
 * @export
 */
export const MiscApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscApiFp(configuration)
    return {
        /**
         * This function retrieves a specified file based on the given filename and type, and streams it to the client. It also handles errors related to file access, returning appropriate HTTP status codes for various scenarios such as file not found or other errors.  # Parameters - `filename`: The name of the file to be downloaded. - `params`: The type of the file, which affects the download behavior.  # Responses - `200`: The file is correctly uploaded. - `400`: You\'re missing some field.  # Errors Returns an error if the file does not exist or if there is an issue with the S3 storage.
         * @summary Downloads files from the server\'s storage.
         * @param {MiscApiDownloadFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(requestParameters: MiscApiDownloadFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.downloadFile(requestParameters.filename, requestParameters.fileType, options).then((request) => request(axios, basePath));
        },
        /**
         * This asynchronous function handles the `/status` endpoint and returns a static string indicating that the server is running. It is commonly used for health checks to confirm that the application is up and operational.  # Returns A static string `\"UP\"`, representing the server\'s status.  # Endpoint - **GET /status**: Responds with `\"UP\"` and a `200 OK` status.
         * @summary Returns the status of the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * # Errors - Returns a 500 status code if there is an internal error, such as a failure to fetch or process Sma data. - Returns a 400 status code if the request to Sma is not correctly formatted.  # Responses - 200: The products have been successfully updated.
         * @summary Updates the local product database by importing products from the Sma API. This function retrieves the latest products from Sma, processes the data, and updates the local products accordingly.
         * @param {MiscApiPostUpdateFromSmaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdateFromSma(requestParameters: MiscApiPostUpdateFromSmaRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SmaResponse> {
            return localVarFp.postUpdateFromSma(requestParameters.name, requestParameters.price, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows an admin user to upload files to a specified S3 bucket. It uses multipart form data to handle file uploads and stores them in a temporary S3 directory.
         * @summary Upload files
         * @param {MiscApiPostUploadFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUploadFiles(requestParameters: MiscApiPostUploadFilesRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postUploadFiles(requestParameters.fileType, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadFile operation in MiscApi.
 * @export
 * @interface MiscApiDownloadFileRequest
 */
export interface MiscApiDownloadFileRequest {
    /**
     * The filename
     * @type {string}
     * @memberof MiscApiDownloadFile
     */
    readonly filename: string

    /**
     * 
     * @type {FileType}
     * @memberof MiscApiDownloadFile
     */
    readonly fileType: FileType
}

/**
 * Request parameters for postUpdateFromSma operation in MiscApi.
 * @export
 * @interface MiscApiPostUpdateFromSmaRequest
 */
export interface MiscApiPostUpdateFromSmaRequest {
    /**
     * Indicates if the product\&#39;s name has changed.
     * @type {boolean}
     * @memberof MiscApiPostUpdateFromSma
     */
    readonly name?: boolean

    /**
     * Indicates if the product\&#39;s price has changed.
     * @type {boolean}
     * @memberof MiscApiPostUpdateFromSma
     */
    readonly price?: boolean
}

/**
 * Request parameters for postUploadFiles operation in MiscApi.
 * @export
 * @interface MiscApiPostUploadFilesRequest
 */
export interface MiscApiPostUploadFilesRequest {
    /**
     * 
     * @type {FileType}
     * @memberof MiscApiPostUploadFiles
     */
    readonly fileType: FileType

    /**
     * Represents the file data
     * @type {File}
     * @memberof MiscApiPostUploadFiles
     */
    readonly file: File
}

/**
 * MiscApi - object-oriented interface
 * @export
 * @class MiscApi
 * @extends {BaseAPI}
 */
export class MiscApi extends BaseAPI {
    /**
     * This function retrieves a specified file based on the given filename and type, and streams it to the client. It also handles errors related to file access, returning appropriate HTTP status codes for various scenarios such as file not found or other errors.  # Parameters - `filename`: The name of the file to be downloaded. - `params`: The type of the file, which affects the download behavior.  # Responses - `200`: The file is correctly uploaded. - `400`: You\'re missing some field.  # Errors Returns an error if the file does not exist or if there is an issue with the S3 storage.
     * @summary Downloads files from the server\'s storage.
     * @param {MiscApiDownloadFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public downloadFile(requestParameters: MiscApiDownloadFileRequest, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).downloadFile(requestParameters.filename, requestParameters.fileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This asynchronous function handles the `/status` endpoint and returns a static string indicating that the server is running. It is commonly used for health checks to confirm that the application is up and operational.  # Returns A static string `\"UP\"`, representing the server\'s status.  # Endpoint - **GET /status**: Responds with `\"UP\"` and a `200 OK` status.
     * @summary Returns the status of the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public getStatus(options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Errors - Returns a 500 status code if there is an internal error, such as a failure to fetch or process Sma data. - Returns a 400 status code if the request to Sma is not correctly formatted.  # Responses - 200: The products have been successfully updated.
     * @summary Updates the local product database by importing products from the Sma API. This function retrieves the latest products from Sma, processes the data, and updates the local products accordingly.
     * @param {MiscApiPostUpdateFromSmaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public postUpdateFromSma(requestParameters: MiscApiPostUpdateFromSmaRequest = {}, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).postUpdateFromSma(requestParameters.name, requestParameters.price, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows an admin user to upload files to a specified S3 bucket. It uses multipart form data to handle file uploads and stores them in a temporary S3 directory.
     * @summary Upload files
     * @param {MiscApiPostUploadFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public postUploadFiles(requestParameters: MiscApiPostUploadFilesRequest, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).postUploadFiles(requestParameters.fileType, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The product is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the product in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The product has been successfully disabled.
         * @summary Deletes a product by its database ID.
         * @param {string} id Product database id to delete product for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProduct', 'id', id)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The admin can change attributes such as the name, price, quantity, or image of the product. If the product image is changed, the old image will be deleted from S3 storage.  Returns an error if the product doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing product by ID in the store.
         * @param {string} id Product database id to edit product for
         * @param {EditProductRequest} editProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProduct: async (id: string, editProductRequest: EditProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editProduct', 'id', id)
            // verify required parameter 'editProductRequest' is not null or undefined
            assertParamExists('editProduct', 'editProductRequest', editProductRequest)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of products per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of products.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see products that are not disabled.
         * @summary Handles the request to retrieve a paginated list of products.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [imageEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [imageNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<number>} [displayOrderEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<number>} [displayOrderNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {number | null} [displayOrderGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {number | null} [displayOrderLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {number | null} [displayOrderGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {number | null} [displayOrderLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [sellPriceEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [sellPriceNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<CurrencyRequest>} [sellPriceCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [sellPriceCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [purchasableEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [purchasableNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<UnitRequest>} [unitEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<UnitRequest>} [unitNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<number>} [maxQuantityPerCommandEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<number>} [maxQuantityPerCommandNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [smaCodeEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [smaCodeNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [inventreeCodeEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [inventreeCodeNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<ProductSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts: async (page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, imageEq?: Array<string>, imageNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, displayOrderEq?: Array<number>, displayOrderNeq?: Array<number>, displayOrderGt?: number | null, displayOrderLt?: number | null, displayOrderGte?: number | null, displayOrderLte?: number | null, sellPriceEq?: Array<string>, sellPriceNeq?: Array<string>, sellPriceCurrencyEq?: Array<CurrencyRequest>, sellPriceCurrencyNeq?: Array<CurrencyRequest>, purchasableEq?: boolean | null, purchasableNeq?: boolean | null, unitEq?: Array<UnitRequest>, unitNeq?: Array<UnitRequest>, maxQuantityPerCommandEq?: Array<number>, maxQuantityPerCommandNeq?: Array<number>, disabledEq?: boolean | null, disabledNeq?: boolean | null, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, smaCodeEq?: Array<string>, smaCodeNeq?: Array<string>, inventreeCodeEq?: Array<string>, inventreeCodeNeq?: Array<string>, sort?: Array<ProductSortEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (idEq) {
                localVarQueryParameter['id_eq'] = idEq;
            }

            if (idNeq) {
                localVarQueryParameter['id_neq'] = idNeq;
            }

            if (imageEq) {
                localVarQueryParameter['image_eq'] = imageEq;
            }

            if (imageNeq) {
                localVarQueryParameter['image_neq'] = imageNeq;
            }

            if (nameEq) {
                localVarQueryParameter['name_eq'] = nameEq;
            }

            if (nameNeq) {
                localVarQueryParameter['name_neq'] = nameNeq;
            }

            if (displayOrderEq) {
                localVarQueryParameter['display_order_eq'] = displayOrderEq;
            }

            if (displayOrderNeq) {
                localVarQueryParameter['display_order_neq'] = displayOrderNeq;
            }

            if (displayOrderGt !== undefined) {
                localVarQueryParameter['display_order_gt'] = displayOrderGt;
            }

            if (displayOrderLt !== undefined) {
                localVarQueryParameter['display_order_lt'] = displayOrderLt;
            }

            if (displayOrderGte !== undefined) {
                localVarQueryParameter['display_order_gte'] = displayOrderGte;
            }

            if (displayOrderLte !== undefined) {
                localVarQueryParameter['display_order_lte'] = displayOrderLte;
            }

            if (sellPriceEq) {
                localVarQueryParameter['sell_price_eq'] = sellPriceEq;
            }

            if (sellPriceNeq) {
                localVarQueryParameter['sell_price_neq'] = sellPriceNeq;
            }

            if (sellPriceCurrencyEq) {
                localVarQueryParameter['sell_price_currency_eq'] = sellPriceCurrencyEq;
            }

            if (sellPriceCurrencyNeq) {
                localVarQueryParameter['sell_price_currency_neq'] = sellPriceCurrencyNeq;
            }

            if (purchasableEq !== undefined) {
                localVarQueryParameter['purchasable_eq'] = purchasableEq;
            }

            if (purchasableNeq !== undefined) {
                localVarQueryParameter['purchasable_neq'] = purchasableNeq;
            }

            if (unitEq) {
                localVarQueryParameter['unit_eq'] = unitEq;
            }

            if (unitNeq) {
                localVarQueryParameter['unit_neq'] = unitNeq;
            }

            if (maxQuantityPerCommandEq) {
                localVarQueryParameter['max_quantity_per_command_eq'] = maxQuantityPerCommandEq;
            }

            if (maxQuantityPerCommandNeq) {
                localVarQueryParameter['max_quantity_per_command_neq'] = maxQuantityPerCommandNeq;
            }

            if (disabledEq !== undefined) {
                localVarQueryParameter['disabled_eq'] = disabledEq;
            }

            if (disabledNeq !== undefined) {
                localVarQueryParameter['disabled_neq'] = disabledNeq;
            }

            if (createdAtEq) {
                localVarQueryParameter['created_at_eq'] = createdAtEq;
            }

            if (createdAtNeq) {
                localVarQueryParameter['created_at_neq'] = createdAtNeq;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString() :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString() :
                    createdAtLt;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (smaCodeEq) {
                localVarQueryParameter['sma_code_eq'] = smaCodeEq;
            }

            if (smaCodeNeq) {
                localVarQueryParameter['sma_code_neq'] = smaCodeNeq;
            }

            if (inventreeCodeEq) {
                localVarQueryParameter['inventree_code_eq'] = inventreeCodeEq;
            }

            if (inventreeCodeNeq) {
                localVarQueryParameter['inventree_code_neq'] = inventreeCodeNeq;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the product to retrieve.  - **Response Codes**:   - `200 OK`: The product was successfully retrieved.   - `404 Not Found`: The product doesn\'t exist, or is disabled and the requester is not an admin.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the product is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a product by its unique identifier.
         * @param {string} id The database ID of the product to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProduct', 'id', id)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function allows an admin to create a new product by sending a POST request to the `/product` endpoint. The new product is validated and stored in the database. The image associated with the product is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the product\'s ID.  Path: `/product`  - **Request Body:** Expects a `NewProduct` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new product, returns the new product\'s ID as a string.
         * @summary Handler for creating a new product.
         * @param {NewProductRequest} newProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewProduct: async (newProductRequest: NewProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newProductRequest' is not null or undefined
            assertParamExists('postNewProduct', 'newProductRequest', newProductRequest)
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * The product is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the product in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The product has been successfully disabled.
         * @summary Deletes a product by its database ID.
         * @param {string} id Product database id to delete product for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.deleteProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The admin can change attributes such as the name, price, quantity, or image of the product. If the product image is changed, the old image will be deleted from S3 storage.  Returns an error if the product doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing product by ID in the store.
         * @param {string} id Product database id to edit product for
         * @param {EditProductRequest} editProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProduct(id: string, editProductRequest: EditProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProduct(id, editProductRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.editProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of products per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of products.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see products that are not disabled.
         * @summary Handles the request to retrieve a paginated list of products.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [imageEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [imageNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<number>} [displayOrderEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<number>} [displayOrderNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {number | null} [displayOrderGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {number | null} [displayOrderLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {number | null} [displayOrderGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {number | null} [displayOrderLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [sellPriceEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [sellPriceNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<CurrencyRequest>} [sellPriceCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [sellPriceCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [purchasableEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [purchasableNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<UnitRequest>} [unitEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<UnitRequest>} [unitNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<number>} [maxQuantityPerCommandEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<number>} [maxQuantityPerCommandNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [smaCodeEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [smaCodeNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [inventreeCodeEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [inventreeCodeNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<ProductSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProducts(page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, imageEq?: Array<string>, imageNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, displayOrderEq?: Array<number>, displayOrderNeq?: Array<number>, displayOrderGt?: number | null, displayOrderLt?: number | null, displayOrderGte?: number | null, displayOrderLte?: number | null, sellPriceEq?: Array<string>, sellPriceNeq?: Array<string>, sellPriceCurrencyEq?: Array<CurrencyRequest>, sellPriceCurrencyNeq?: Array<CurrencyRequest>, purchasableEq?: boolean | null, purchasableNeq?: boolean | null, unitEq?: Array<UnitRequest>, unitNeq?: Array<UnitRequest>, maxQuantityPerCommandEq?: Array<number>, maxQuantityPerCommandNeq?: Array<number>, disabledEq?: boolean | null, disabledNeq?: boolean | null, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, smaCodeEq?: Array<string>, smaCodeNeq?: Array<string>, inventreeCodeEq?: Array<string>, inventreeCodeNeq?: Array<string>, sort?: Array<ProductSortEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProducts(page, perPage, idEq, idNeq, imageEq, imageNeq, nameEq, nameNeq, displayOrderEq, displayOrderNeq, displayOrderGt, displayOrderLt, displayOrderGte, displayOrderLte, sellPriceEq, sellPriceNeq, sellPriceCurrencyEq, sellPriceCurrencyNeq, purchasableEq, purchasableNeq, unitEq, unitNeq, maxQuantityPerCommandEq, maxQuantityPerCommandNeq, disabledEq, disabledNeq, createdAtEq, createdAtNeq, createdAtGt, createdAtLt, createdAtGte, createdAtLte, smaCodeEq, smaCodeNeq, inventreeCodeEq, inventreeCodeNeq, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.getAllProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the product to retrieve.  - **Response Codes**:   - `200 OK`: The product was successfully retrieved.   - `404 Not Found`: The product doesn\'t exist, or is disabled and the requester is not an admin.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the product is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a product by its unique identifier.
         * @param {string} id The database ID of the product to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.getProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function allows an admin to create a new product by sending a POST request to the `/product` endpoint. The new product is validated and stored in the database. The image associated with the product is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the product\'s ID.  Path: `/product`  - **Request Body:** Expects a `NewProduct` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new product, returns the new product\'s ID as a string.
         * @summary Handler for creating a new product.
         * @param {NewProductRequest} newProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNewProduct(newProductRequest: NewProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNewProduct(newProductRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.postNewProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * The product is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the product in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The product has been successfully disabled.
         * @summary Deletes a product by its database ID.
         * @param {ProductApiDeleteProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(requestParameters: ProductApiDeleteProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProduct(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * The admin can change attributes such as the name, price, quantity, or image of the product. If the product image is changed, the old image will be deleted from S3 storage.  Returns an error if the product doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing product by ID in the store.
         * @param {ProductApiEditProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProduct(requestParameters: ProductApiEditProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editProduct(requestParameters.id, requestParameters.editProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of products per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of products.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see products that are not disabled.
         * @summary Handles the request to retrieve a paginated list of products.
         * @param {ProductApiGetAllProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(requestParameters: ProductApiGetAllProductsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ProductListResponse> {
            return localVarFp.getAllProducts(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.imageEq, requestParameters.imageNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.displayOrderEq, requestParameters.displayOrderNeq, requestParameters.displayOrderGt, requestParameters.displayOrderLt, requestParameters.displayOrderGte, requestParameters.displayOrderLte, requestParameters.sellPriceEq, requestParameters.sellPriceNeq, requestParameters.sellPriceCurrencyEq, requestParameters.sellPriceCurrencyNeq, requestParameters.purchasableEq, requestParameters.purchasableNeq, requestParameters.unitEq, requestParameters.unitNeq, requestParameters.maxQuantityPerCommandEq, requestParameters.maxQuantityPerCommandNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.smaCodeEq, requestParameters.smaCodeNeq, requestParameters.inventreeCodeEq, requestParameters.inventreeCodeNeq, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the product to retrieve.  - **Response Codes**:   - `200 OK`: The product was successfully retrieved.   - `404 Not Found`: The product doesn\'t exist, or is disabled and the requester is not an admin.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the product is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a product by its unique identifier.
         * @param {ProductApiGetProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(requestParameters: ProductApiGetProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductResponse> {
            return localVarFp.getProduct(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This function allows an admin to create a new product by sending a POST request to the `/product` endpoint. The new product is validated and stored in the database. The image associated with the product is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the product\'s ID.  Path: `/product`  - **Request Body:** Expects a `NewProduct` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new product, returns the new product\'s ID as a string.
         * @summary Handler for creating a new product.
         * @param {ProductApiPostNewProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewProduct(requestParameters: ProductApiPostNewProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postNewProduct(requestParameters.newProductRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteProduct operation in ProductApi.
 * @export
 * @interface ProductApiDeleteProductRequest
 */
export interface ProductApiDeleteProductRequest {
    /**
     * Product database id to delete product for
     * @type {string}
     * @memberof ProductApiDeleteProduct
     */
    readonly id: string
}

/**
 * Request parameters for editProduct operation in ProductApi.
 * @export
 * @interface ProductApiEditProductRequest
 */
export interface ProductApiEditProductRequest {
    /**
     * Product database id to edit product for
     * @type {string}
     * @memberof ProductApiEditProduct
     */
    readonly id: string

    /**
     * 
     * @type {EditProductRequest}
     * @memberof ProductApiEditProduct
     */
    readonly editProductRequest: EditProductRequest
}

/**
 * Request parameters for getAllProducts operation in ProductApi.
 * @export
 * @interface ProductApiGetAllProductsRequest
 */
export interface ProductApiGetAllProductsRequest {
    /**
     * The page number to retrieve, starting from 0.
     * @type {number}
     * @memberof ProductApiGetAllProducts
     */
    readonly page?: number | null

    /**
     * The number of items to return per page.
     * @type {number}
     * @memberof ProductApiGetAllProducts
     */
    readonly perPage?: number | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly idEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly idNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly imageEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly imageNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly nameEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly nameNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<number>}
     * @memberof ProductApiGetAllProducts
     */
    readonly displayOrderEq?: Array<number>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<number>}
     * @memberof ProductApiGetAllProducts
     */
    readonly displayOrderNeq?: Array<number>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {number}
     * @memberof ProductApiGetAllProducts
     */
    readonly displayOrderGt?: number | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {number}
     * @memberof ProductApiGetAllProducts
     */
    readonly displayOrderLt?: number | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {number}
     * @memberof ProductApiGetAllProducts
     */
    readonly displayOrderGte?: number | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {number}
     * @memberof ProductApiGetAllProducts
     */
    readonly displayOrderLte?: number | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly sellPriceEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly sellPriceNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof ProductApiGetAllProducts
     */
    readonly sellPriceCurrencyEq?: Array<CurrencyRequest>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof ProductApiGetAllProducts
     */
    readonly sellPriceCurrencyNeq?: Array<CurrencyRequest>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof ProductApiGetAllProducts
     */
    readonly purchasableEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof ProductApiGetAllProducts
     */
    readonly purchasableNeq?: boolean | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<UnitRequest>}
     * @memberof ProductApiGetAllProducts
     */
    readonly unitEq?: Array<UnitRequest>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<UnitRequest>}
     * @memberof ProductApiGetAllProducts
     */
    readonly unitNeq?: Array<UnitRequest>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<number>}
     * @memberof ProductApiGetAllProducts
     */
    readonly maxQuantityPerCommandEq?: Array<number>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<number>}
     * @memberof ProductApiGetAllProducts
     */
    readonly maxQuantityPerCommandNeq?: Array<number>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof ProductApiGetAllProducts
     */
    readonly disabledEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof ProductApiGetAllProducts
     */
    readonly disabledNeq?: boolean | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly createdAtEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly createdAtNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof ProductApiGetAllProducts
     */
    readonly createdAtGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof ProductApiGetAllProducts
     */
    readonly createdAtLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof ProductApiGetAllProducts
     */
    readonly createdAtGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof ProductApiGetAllProducts
     */
    readonly createdAtLte?: string | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly smaCodeEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly smaCodeNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly inventreeCodeEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly inventreeCodeNeq?: Array<string>

    /**
     * Used for sorting the output
     * @type {Array<ProductSortEnum>}
     * @memberof ProductApiGetAllProducts
     */
    readonly sort?: Array<ProductSortEnum>
}

/**
 * Request parameters for getProduct operation in ProductApi.
 * @export
 * @interface ProductApiGetProductRequest
 */
export interface ProductApiGetProductRequest {
    /**
     * The database ID of the product to retrieve.
     * @type {string}
     * @memberof ProductApiGetProduct
     */
    readonly id: string
}

/**
 * Request parameters for postNewProduct operation in ProductApi.
 * @export
 * @interface ProductApiPostNewProductRequest
 */
export interface ProductApiPostNewProductRequest {
    /**
     * 
     * @type {NewProductRequest}
     * @memberof ProductApiPostNewProduct
     */
    readonly newProductRequest: NewProductRequest
}

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * The product is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the product in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The product has been successfully disabled.
     * @summary Deletes a product by its database ID.
     * @param {ProductApiDeleteProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public deleteProduct(requestParameters: ProductApiDeleteProductRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).deleteProduct(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The admin can change attributes such as the name, price, quantity, or image of the product. If the product image is changed, the old image will be deleted from S3 storage.  Returns an error if the product doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
     * @summary Edit an existing product by ID in the store.
     * @param {ProductApiEditProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public editProduct(requestParameters: ProductApiEditProductRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).editProduct(requestParameters.id, requestParameters.editProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of products per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of products.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see products that are not disabled.
     * @summary Handles the request to retrieve a paginated list of products.
     * @param {ProductApiGetAllProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getAllProducts(requestParameters: ProductApiGetAllProductsRequest = {}, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).getAllProducts(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.imageEq, requestParameters.imageNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.displayOrderEq, requestParameters.displayOrderNeq, requestParameters.displayOrderGt, requestParameters.displayOrderLt, requestParameters.displayOrderGte, requestParameters.displayOrderLte, requestParameters.sellPriceEq, requestParameters.sellPriceNeq, requestParameters.sellPriceCurrencyEq, requestParameters.sellPriceCurrencyNeq, requestParameters.purchasableEq, requestParameters.purchasableNeq, requestParameters.unitEq, requestParameters.unitNeq, requestParameters.maxQuantityPerCommandEq, requestParameters.maxQuantityPerCommandNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.smaCodeEq, requestParameters.smaCodeNeq, requestParameters.inventreeCodeEq, requestParameters.inventreeCodeNeq, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Path Parameters**:   `id` (UUID): The database ID of the product to retrieve.  - **Response Codes**:   - `200 OK`: The product was successfully retrieved.   - `404 Not Found`: The product doesn\'t exist, or is disabled and the requester is not an admin.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the product is disabled, only an admin can retrieve it.
     * @summary Handles the request to fetch a product by its unique identifier.
     * @param {ProductApiGetProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProduct(requestParameters: ProductApiGetProductRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).getProduct(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function allows an admin to create a new product by sending a POST request to the `/product` endpoint. The new product is validated and stored in the database. The image associated with the product is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the product\'s ID.  Path: `/product`  - **Request Body:** Expects a `NewProduct` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new product, returns the new product\'s ID as a string.
     * @summary Handler for creating a new product.
     * @param {ProductApiPostNewProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public postNewProduct(requestParameters: ProductApiPostNewProductRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).postNewProduct(requestParameters.newProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RefillApi - axios parameter creator
 * @export
 */
export const RefillApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The refill is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the refill in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The refill has been successfully disabled.
         * @summary Deletes a refill by its database ID.
         * @param {string} id refill database id to delete refill for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRefill: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRefill', 'id', id)
            const localVarPath = `/refill/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The admin can change attributes such as the name, amont_in_euro, amont_in_epicoin of the refill.  Returns an error if the refill doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing refill by ID in the store.
         * @param {string} id refill database id to edit refill for
         * @param {EditRefillRequest} editRefillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRefill: async (id: string, editRefillRequest: EditRefillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editRefill', 'id', id)
            // verify required parameter 'editRefillRequest' is not null or undefined
            assertParamExists('editRefill', 'editRefillRequest', editRefillRequest)
            const localVarPath = `/refill/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editRefillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of refill per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of refills.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view disabled refill
         * @summary Handles the request to retrieve a paginated list of refills.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [priceEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [priceNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<CurrencyRequest>} [priceCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [priceCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [creditEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [creditNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<CurrencyRequest>} [creditCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [creditCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<RefillSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRefills: async (page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, priceEq?: Array<string>, priceNeq?: Array<string>, priceCurrencyEq?: Array<CurrencyRequest>, priceCurrencyNeq?: Array<CurrencyRequest>, creditEq?: Array<string>, creditNeq?: Array<string>, creditCurrencyEq?: Array<CurrencyRequest>, creditCurrencyNeq?: Array<CurrencyRequest>, disabledEq?: boolean | null, disabledNeq?: boolean | null, sort?: Array<RefillSortEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/refill`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (idEq) {
                localVarQueryParameter['id_eq'] = idEq;
            }

            if (idNeq) {
                localVarQueryParameter['id_neq'] = idNeq;
            }

            if (nameEq) {
                localVarQueryParameter['name_eq'] = nameEq;
            }

            if (nameNeq) {
                localVarQueryParameter['name_neq'] = nameNeq;
            }

            if (createdAtEq) {
                localVarQueryParameter['created_at_eq'] = createdAtEq;
            }

            if (createdAtNeq) {
                localVarQueryParameter['created_at_neq'] = createdAtNeq;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString() :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString() :
                    createdAtLt;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (priceEq) {
                localVarQueryParameter['price_eq'] = priceEq;
            }

            if (priceNeq) {
                localVarQueryParameter['price_neq'] = priceNeq;
            }

            if (priceCurrencyEq) {
                localVarQueryParameter['price_currency_eq'] = priceCurrencyEq;
            }

            if (priceCurrencyNeq) {
                localVarQueryParameter['price_currency_neq'] = priceCurrencyNeq;
            }

            if (creditEq) {
                localVarQueryParameter['credit_eq'] = creditEq;
            }

            if (creditNeq) {
                localVarQueryParameter['credit_neq'] = creditNeq;
            }

            if (creditCurrencyEq) {
                localVarQueryParameter['credit_currency_eq'] = creditCurrencyEq;
            }

            if (creditCurrencyNeq) {
                localVarQueryParameter['credit_currency_neq'] = creditCurrencyNeq;
            }

            if (disabledEq !== undefined) {
                localVarQueryParameter['disabled_eq'] = disabledEq;
            }

            if (disabledNeq !== undefined) {
                localVarQueryParameter['disabled_neq'] = disabledNeq;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the refill to retrieve.  - **Response Codes**:   - `200 OK`: The refill was successfully retrieved.   - `404 Not Found`: The refill doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the refill is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a refill by its unique identifier.
         * @param {string} id The database ID of the refill to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefill: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRefill', 'id', id)
            const localVarPath = `/refill/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function allows an admin to create a new refill by sending a POST request to the `/refill` endpoint. The new refill is validated and stored in the database. The image associated with the refill is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the refill\'s ID.  Path: `/refill`  - **Request Body:** Expects a `NewRefill` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new refill, returns the new refill\'s ID as a string.
         * @summary Handler for creating a new refill.
         * @param {NewRefillRequest} newRefillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewRefill: async (newRefillRequest: NewRefillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newRefillRequest' is not null or undefined
            assertParamExists('postNewRefill', 'newRefillRequest', newRefillRequest)
            const localVarPath = `/refill`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newRefillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefillApi - functional programming interface
 * @export
 */
export const RefillApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefillApiAxiosParamCreator(configuration)
    return {
        /**
         * The refill is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the refill in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The refill has been successfully disabled.
         * @summary Deletes a refill by its database ID.
         * @param {string} id refill database id to delete refill for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRefill(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRefill(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillApi.deleteRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The admin can change attributes such as the name, amont_in_euro, amont_in_epicoin of the refill.  Returns an error if the refill doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing refill by ID in the store.
         * @param {string} id refill database id to edit refill for
         * @param {EditRefillRequest} editRefillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editRefill(id: string, editRefillRequest: EditRefillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editRefill(id, editRefillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillApi.editRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of refill per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of refills.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view disabled refill
         * @summary Handles the request to retrieve a paginated list of refills.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [priceEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [priceNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<CurrencyRequest>} [priceCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [priceCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [creditEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [creditNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<CurrencyRequest>} [creditCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [creditCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<RefillSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRefills(page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, priceEq?: Array<string>, priceNeq?: Array<string>, priceCurrencyEq?: Array<CurrencyRequest>, priceCurrencyNeq?: Array<CurrencyRequest>, creditEq?: Array<string>, creditNeq?: Array<string>, creditCurrencyEq?: Array<CurrencyRequest>, creditCurrencyNeq?: Array<CurrencyRequest>, disabledEq?: boolean | null, disabledNeq?: boolean | null, sort?: Array<RefillSortEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefillListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRefills(page, perPage, idEq, idNeq, nameEq, nameNeq, createdAtEq, createdAtNeq, createdAtGt, createdAtLt, createdAtGte, createdAtLte, priceEq, priceNeq, priceCurrencyEq, priceCurrencyNeq, creditEq, creditNeq, creditCurrencyEq, creditCurrencyNeq, disabledEq, disabledNeq, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillApi.getAllRefills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the refill to retrieve.  - **Response Codes**:   - `200 OK`: The refill was successfully retrieved.   - `404 Not Found`: The refill doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the refill is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a refill by its unique identifier.
         * @param {string} id The database ID of the refill to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRefill(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefillResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRefill(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillApi.getRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function allows an admin to create a new refill by sending a POST request to the `/refill` endpoint. The new refill is validated and stored in the database. The image associated with the refill is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the refill\'s ID.  Path: `/refill`  - **Request Body:** Expects a `NewRefill` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new refill, returns the new refill\'s ID as a string.
         * @summary Handler for creating a new refill.
         * @param {NewRefillRequest} newRefillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNewRefill(newRefillRequest: NewRefillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNewRefill(newRefillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillApi.postNewRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RefillApi - factory interface
 * @export
 */
export const RefillApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefillApiFp(configuration)
    return {
        /**
         * The refill is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the refill in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The refill has been successfully disabled.
         * @summary Deletes a refill by its database ID.
         * @param {RefillApiDeleteRefillRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRefill(requestParameters: RefillApiDeleteRefillRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRefill(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * The admin can change attributes such as the name, amont_in_euro, amont_in_epicoin of the refill.  Returns an error if the refill doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing refill by ID in the store.
         * @param {RefillApiEditRefillRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRefill(requestParameters: RefillApiEditRefillRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editRefill(requestParameters.id, requestParameters.editRefillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of refill per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of refills.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view disabled refill
         * @summary Handles the request to retrieve a paginated list of refills.
         * @param {RefillApiGetAllRefillsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRefills(requestParameters: RefillApiGetAllRefillsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<RefillListResponse> {
            return localVarFp.getAllRefills(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.priceEq, requestParameters.priceNeq, requestParameters.priceCurrencyEq, requestParameters.priceCurrencyNeq, requestParameters.creditEq, requestParameters.creditNeq, requestParameters.creditCurrencyEq, requestParameters.creditCurrencyNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the refill to retrieve.  - **Response Codes**:   - `200 OK`: The refill was successfully retrieved.   - `404 Not Found`: The refill doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the refill is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a refill by its unique identifier.
         * @param {RefillApiGetRefillRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefill(requestParameters: RefillApiGetRefillRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefillResponse> {
            return localVarFp.getRefill(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This function allows an admin to create a new refill by sending a POST request to the `/refill` endpoint. The new refill is validated and stored in the database. The image associated with the refill is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the refill\'s ID.  Path: `/refill`  - **Request Body:** Expects a `NewRefill` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new refill, returns the new refill\'s ID as a string.
         * @summary Handler for creating a new refill.
         * @param {RefillApiPostNewRefillRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewRefill(requestParameters: RefillApiPostNewRefillRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postNewRefill(requestParameters.newRefillRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteRefill operation in RefillApi.
 * @export
 * @interface RefillApiDeleteRefillRequest
 */
export interface RefillApiDeleteRefillRequest {
    /**
     * refill database id to delete refill for
     * @type {string}
     * @memberof RefillApiDeleteRefill
     */
    readonly id: string
}

/**
 * Request parameters for editRefill operation in RefillApi.
 * @export
 * @interface RefillApiEditRefillRequest
 */
export interface RefillApiEditRefillRequest {
    /**
     * refill database id to edit refill for
     * @type {string}
     * @memberof RefillApiEditRefill
     */
    readonly id: string

    /**
     * 
     * @type {EditRefillRequest}
     * @memberof RefillApiEditRefill
     */
    readonly editRefillRequest: EditRefillRequest
}

/**
 * Request parameters for getAllRefills operation in RefillApi.
 * @export
 * @interface RefillApiGetAllRefillsRequest
 */
export interface RefillApiGetAllRefillsRequest {
    /**
     * The page number to retrieve, starting from 0.
     * @type {number}
     * @memberof RefillApiGetAllRefills
     */
    readonly page?: number | null

    /**
     * The number of items to return per page.
     * @type {number}
     * @memberof RefillApiGetAllRefills
     */
    readonly perPage?: number | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly idEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly idNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly nameEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly nameNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly createdAtEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly createdAtNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof RefillApiGetAllRefills
     */
    readonly createdAtGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof RefillApiGetAllRefills
     */
    readonly createdAtLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof RefillApiGetAllRefills
     */
    readonly createdAtGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof RefillApiGetAllRefills
     */
    readonly createdAtLte?: string | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly priceEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly priceNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof RefillApiGetAllRefills
     */
    readonly priceCurrencyEq?: Array<CurrencyRequest>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof RefillApiGetAllRefills
     */
    readonly priceCurrencyNeq?: Array<CurrencyRequest>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly creditEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly creditNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof RefillApiGetAllRefills
     */
    readonly creditCurrencyEq?: Array<CurrencyRequest>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof RefillApiGetAllRefills
     */
    readonly creditCurrencyNeq?: Array<CurrencyRequest>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof RefillApiGetAllRefills
     */
    readonly disabledEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof RefillApiGetAllRefills
     */
    readonly disabledNeq?: boolean | null

    /**
     * Used for sorting the output
     * @type {Array<RefillSortEnum>}
     * @memberof RefillApiGetAllRefills
     */
    readonly sort?: Array<RefillSortEnum>
}

/**
 * Request parameters for getRefill operation in RefillApi.
 * @export
 * @interface RefillApiGetRefillRequest
 */
export interface RefillApiGetRefillRequest {
    /**
     * The database ID of the refill to retrieve.
     * @type {string}
     * @memberof RefillApiGetRefill
     */
    readonly id: string
}

/**
 * Request parameters for postNewRefill operation in RefillApi.
 * @export
 * @interface RefillApiPostNewRefillRequest
 */
export interface RefillApiPostNewRefillRequest {
    /**
     * 
     * @type {NewRefillRequest}
     * @memberof RefillApiPostNewRefill
     */
    readonly newRefillRequest: NewRefillRequest
}

/**
 * RefillApi - object-oriented interface
 * @export
 * @class RefillApi
 * @extends {BaseAPI}
 */
export class RefillApi extends BaseAPI {
    /**
     * The refill is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the refill in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The refill has been successfully disabled.
     * @summary Deletes a refill by its database ID.
     * @param {RefillApiDeleteRefillRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillApi
     */
    public deleteRefill(requestParameters: RefillApiDeleteRefillRequest, options?: RawAxiosRequestConfig) {
        return RefillApiFp(this.configuration).deleteRefill(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The admin can change attributes such as the name, amont_in_euro, amont_in_epicoin of the refill.  Returns an error if the refill doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
     * @summary Edit an existing refill by ID in the store.
     * @param {RefillApiEditRefillRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillApi
     */
    public editRefill(requestParameters: RefillApiEditRefillRequest, options?: RawAxiosRequestConfig) {
        return RefillApiFp(this.configuration).editRefill(requestParameters.id, requestParameters.editRefillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of refill per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of refills.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view disabled refill
     * @summary Handles the request to retrieve a paginated list of refills.
     * @param {RefillApiGetAllRefillsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillApi
     */
    public getAllRefills(requestParameters: RefillApiGetAllRefillsRequest = {}, options?: RawAxiosRequestConfig) {
        return RefillApiFp(this.configuration).getAllRefills(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.priceEq, requestParameters.priceNeq, requestParameters.priceCurrencyEq, requestParameters.priceCurrencyNeq, requestParameters.creditEq, requestParameters.creditNeq, requestParameters.creditCurrencyEq, requestParameters.creditCurrencyNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Path Parameters**:   `id` (UUID): The database ID of the refill to retrieve.  - **Response Codes**:   - `200 OK`: The refill was successfully retrieved.   - `404 Not Found`: The refill doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the refill is disabled, only an admin can retrieve it.
     * @summary Handles the request to fetch a refill by its unique identifier.
     * @param {RefillApiGetRefillRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillApi
     */
    public getRefill(requestParameters: RefillApiGetRefillRequest, options?: RawAxiosRequestConfig) {
        return RefillApiFp(this.configuration).getRefill(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function allows an admin to create a new refill by sending a POST request to the `/refill` endpoint. The new refill is validated and stored in the database. The image associated with the refill is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the refill\'s ID.  Path: `/refill`  - **Request Body:** Expects a `NewRefill` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new refill, returns the new refill\'s ID as a string.
     * @summary Handler for creating a new refill.
     * @param {RefillApiPostNewRefillRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillApi
     */
    public postNewRefill(requestParameters: RefillApiPostNewRefillRequest, options?: RawAxiosRequestConfig) {
        return RefillApiFp(this.configuration).postNewRefill(requestParameters.newRefillRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an error if the user doesn\'t exist, if there is a validation issue, or if a database.
         * @summary Edit an existing user by ID.
         * @param {string} id user database id to edit user for
         * @param {EditUserRequest} editUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser: async (id: string, editUserRequest: EditUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editUser', 'id', id)
            // verify required parameter 'editUserRequest' is not null or undefined
            assertParamExists('editUser', 'editUserRequest', editUserRequest)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of user per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of users.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view others users
         * @summary Handles the request to retrieve a paginated list of users.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [emailEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [emailNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [usernameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [usernameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [balanceEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [balanceNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [balanceGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [balanceLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [balanceGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [balanceLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<CurrencyRequest>} [balanceCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [balanceCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [isAdminEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [isAdminNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {boolean | null} [isBannedEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [isBannedNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [lastAccessAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [lastAccessAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [lastAccessAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [lastAccessAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [lastAccessAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [lastAccessAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<UserSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, emailEq?: Array<string>, emailNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, usernameEq?: Array<string>, usernameNeq?: Array<string>, balanceEq?: Array<string>, balanceNeq?: Array<string>, balanceGt?: string | null, balanceLt?: string | null, balanceGte?: string | null, balanceLte?: string | null, balanceCurrencyEq?: Array<CurrencyRequest>, balanceCurrencyNeq?: Array<CurrencyRequest>, isAdminEq?: boolean | null, isAdminNeq?: boolean | null, isBannedEq?: boolean | null, isBannedNeq?: boolean | null, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, lastAccessAtEq?: Array<string>, lastAccessAtNeq?: Array<string>, lastAccessAtGt?: string | null, lastAccessAtLt?: string | null, lastAccessAtGte?: string | null, lastAccessAtLte?: string | null, sort?: Array<UserSortEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (idEq) {
                localVarQueryParameter['id_eq'] = idEq;
            }

            if (idNeq) {
                localVarQueryParameter['id_neq'] = idNeq;
            }

            if (emailEq) {
                localVarQueryParameter['email_eq'] = emailEq;
            }

            if (emailNeq) {
                localVarQueryParameter['email_neq'] = emailNeq;
            }

            if (nameEq) {
                localVarQueryParameter['name_eq'] = nameEq;
            }

            if (nameNeq) {
                localVarQueryParameter['name_neq'] = nameNeq;
            }

            if (usernameEq) {
                localVarQueryParameter['username_eq'] = usernameEq;
            }

            if (usernameNeq) {
                localVarQueryParameter['username_neq'] = usernameNeq;
            }

            if (balanceEq) {
                localVarQueryParameter['balance_eq'] = balanceEq;
            }

            if (balanceNeq) {
                localVarQueryParameter['balance_neq'] = balanceNeq;
            }

            if (balanceGt !== undefined) {
                localVarQueryParameter['balance_gt'] = balanceGt;
            }

            if (balanceLt !== undefined) {
                localVarQueryParameter['balance_lt'] = balanceLt;
            }

            if (balanceGte !== undefined) {
                localVarQueryParameter['balance_gte'] = balanceGte;
            }

            if (balanceLte !== undefined) {
                localVarQueryParameter['balance_lte'] = balanceLte;
            }

            if (balanceCurrencyEq) {
                localVarQueryParameter['balance_currency_eq'] = balanceCurrencyEq;
            }

            if (balanceCurrencyNeq) {
                localVarQueryParameter['balance_currency_neq'] = balanceCurrencyNeq;
            }

            if (isAdminEq !== undefined) {
                localVarQueryParameter['is_admin_eq'] = isAdminEq;
            }

            if (isAdminNeq !== undefined) {
                localVarQueryParameter['is_admin_neq'] = isAdminNeq;
            }

            if (isBannedEq !== undefined) {
                localVarQueryParameter['is_banned_eq'] = isBannedEq;
            }

            if (isBannedNeq !== undefined) {
                localVarQueryParameter['is_banned_neq'] = isBannedNeq;
            }

            if (createdAtEq) {
                localVarQueryParameter['created_at_eq'] = createdAtEq;
            }

            if (createdAtNeq) {
                localVarQueryParameter['created_at_neq'] = createdAtNeq;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString() :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString() :
                    createdAtLt;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (lastAccessAtEq) {
                localVarQueryParameter['last_access_at_eq'] = lastAccessAtEq;
            }

            if (lastAccessAtNeq) {
                localVarQueryParameter['last_access_at_neq'] = lastAccessAtNeq;
            }

            if (lastAccessAtGt !== undefined) {
                localVarQueryParameter['last_access_at_gt'] = (lastAccessAtGt as any instanceof Date) ?
                    (lastAccessAtGt as any).toISOString() :
                    lastAccessAtGt;
            }

            if (lastAccessAtLt !== undefined) {
                localVarQueryParameter['last_access_at_lt'] = (lastAccessAtLt as any instanceof Date) ?
                    (lastAccessAtLt as any).toISOString() :
                    lastAccessAtLt;
            }

            if (lastAccessAtGte !== undefined) {
                localVarQueryParameter['last_access_at_gte'] = (lastAccessAtGte as any instanceof Date) ?
                    (lastAccessAtGte as any).toISOString() :
                    lastAccessAtGte;
            }

            if (lastAccessAtLte !== undefined) {
                localVarQueryParameter['last_access_at_lte'] = (lastAccessAtLte as any instanceof Date) ?
                    (lastAccessAtLte as any).toISOString() :
                    lastAccessAtLte;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function is responsible for handling login requests. When a user attempts to access the login route, they are redirected to the frontend base URL specified in the application\'s configuration (command-line arguments or environment variables).  
         * @summary Handles the login route by redirecting the user to the frontend.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogin: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function manages user logout by initiating an OIDC provider-initiated logout and then redirecting the user to the frontend base URL.
         * @summary Handles the logout process by initiating a logout request with the OIDC provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function checks if a user is authenticated using the optional `User`. If the user is logged in, their information (ID, username, email, etc...) is returned as a JSON response. If not logged in, it returns a `204 No Content` response, indicating the user is not authenticated.
         * @summary Handles the `/me` route, returning the current user\'s information if authenticated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the user to retrieve.  - **Response Codes**:   - `200 OK`: The user was successfully retrieved.   - `404 Not Found`: The user doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the user is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a user by its unique identifier.
         * @param {string} id The database ID of the user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns an error if the user doesn\'t exist, if there is a validation issue, or if a database.
         * @summary Edit an existing user by ID.
         * @param {string} id user database id to edit user for
         * @param {EditUserRequest} editUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUser(id: string, editUserRequest: EditUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUser(id, editUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.editUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of user per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of users.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view others users
         * @summary Handles the request to retrieve a paginated list of users.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [emailEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [emailNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [usernameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [usernameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [balanceEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [balanceNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [balanceGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [balanceLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [balanceGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [balanceLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<CurrencyRequest>} [balanceCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [balanceCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [isAdminEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [isAdminNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {boolean | null} [isBannedEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [isBannedNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [lastAccessAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [lastAccessAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [lastAccessAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [lastAccessAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [lastAccessAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [lastAccessAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<UserSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, emailEq?: Array<string>, emailNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, usernameEq?: Array<string>, usernameNeq?: Array<string>, balanceEq?: Array<string>, balanceNeq?: Array<string>, balanceGt?: string | null, balanceLt?: string | null, balanceGte?: string | null, balanceLte?: string | null, balanceCurrencyEq?: Array<CurrencyRequest>, balanceCurrencyNeq?: Array<CurrencyRequest>, isAdminEq?: boolean | null, isAdminNeq?: boolean | null, isBannedEq?: boolean | null, isBannedNeq?: boolean | null, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, lastAccessAtEq?: Array<string>, lastAccessAtNeq?: Array<string>, lastAccessAtGt?: string | null, lastAccessAtLt?: string | null, lastAccessAtGte?: string | null, lastAccessAtLte?: string | null, sort?: Array<UserSortEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(page, perPage, idEq, idNeq, emailEq, emailNeq, nameEq, nameNeq, usernameEq, usernameNeq, balanceEq, balanceNeq, balanceGt, balanceLt, balanceGte, balanceLte, balanceCurrencyEq, balanceCurrencyNeq, isAdminEq, isAdminNeq, isBannedEq, isBannedNeq, createdAtEq, createdAtNeq, createdAtGt, createdAtLt, createdAtGte, createdAtLte, lastAccessAtEq, lastAccessAtNeq, lastAccessAtGt, lastAccessAtLt, lastAccessAtGte, lastAccessAtLte, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function is responsible for handling login requests. When a user attempts to access the login route, they are redirected to the frontend base URL specified in the application\'s configuration (command-line arguments or environment variables).  
         * @summary Handles the login route by redirecting the user to the frontend.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogin(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogin(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function manages user logout by initiating an OIDC provider-initiated logout and then redirecting the user to the frontend base URL.
         * @summary Handles the logout process by initiating a logout request with the OIDC provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function checks if a user is authenticated using the optional `User`. If the user is logged in, their information (ID, username, email, etc...) is returned as a JSON response. If not logged in, it returns a `204 No Content` response, indicating the user is not authenticated.
         * @summary Handles the `/me` route, returning the current user\'s information if authenticated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the user to retrieve.  - **Response Codes**:   - `200 OK`: The user was successfully retrieved.   - `404 Not Found`: The user doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the user is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a user by its unique identifier.
         * @param {string} id The database ID of the user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Returns an error if the user doesn\'t exist, if there is a validation issue, or if a database.
         * @summary Edit an existing user by ID.
         * @param {UserApiEditUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(requestParameters: UserApiEditUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editUser(requestParameters.id, requestParameters.editUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of user per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of users.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view others users
         * @summary Handles the request to retrieve a paginated list of users.
         * @param {UserApiGetAllUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(requestParameters: UserApiGetAllUsersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserListResponse> {
            return localVarFp.getAllUsers(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.emailEq, requestParameters.emailNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.usernameEq, requestParameters.usernameNeq, requestParameters.balanceEq, requestParameters.balanceNeq, requestParameters.balanceGt, requestParameters.balanceLt, requestParameters.balanceGte, requestParameters.balanceLte, requestParameters.balanceCurrencyEq, requestParameters.balanceCurrencyNeq, requestParameters.isAdminEq, requestParameters.isAdminNeq, requestParameters.isBannedEq, requestParameters.isBannedNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.lastAccessAtEq, requestParameters.lastAccessAtNeq, requestParameters.lastAccessAtGt, requestParameters.lastAccessAtLt, requestParameters.lastAccessAtGte, requestParameters.lastAccessAtLte, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * This function is responsible for handling login requests. When a user attempts to access the login route, they are redirected to the frontend base URL specified in the application\'s configuration (command-line arguments or environment variables).  
         * @summary Handles the login route by redirecting the user to the frontend.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogin(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getLogin(options).then((request) => request(axios, basePath));
        },
        /**
         * This function manages user logout by initiating an OIDC provider-initiated logout and then redirecting the user to the frontend base URL.
         * @summary Handles the logout process by initiating a logout request with the OIDC provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * This function checks if a user is authenticated using the optional `User`. If the user is logged in, their information (ID, username, email, etc...) is returned as a JSON response. If not logged in, it returns a `204 No Content` response, indicating the user is not authenticated.
         * @summary Handles the `/me` route, returning the current user\'s information if authenticated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the user to retrieve.  - **Response Codes**:   - `200 OK`: The user was successfully retrieved.   - `404 Not Found`: The user doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the user is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a user by its unique identifier.
         * @param {UserApiGetUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(requestParameters: UserApiGetUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.getUser(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for editUser operation in UserApi.
 * @export
 * @interface UserApiEditUserRequest
 */
export interface UserApiEditUserRequest {
    /**
     * user database id to edit user for
     * @type {string}
     * @memberof UserApiEditUser
     */
    readonly id: string

    /**
     * 
     * @type {EditUserRequest}
     * @memberof UserApiEditUser
     */
    readonly editUserRequest: EditUserRequest
}

/**
 * Request parameters for getAllUsers operation in UserApi.
 * @export
 * @interface UserApiGetAllUsersRequest
 */
export interface UserApiGetAllUsersRequest {
    /**
     * The page number to retrieve, starting from 0.
     * @type {number}
     * @memberof UserApiGetAllUsers
     */
    readonly page?: number | null

    /**
     * The number of items to return per page.
     * @type {number}
     * @memberof UserApiGetAllUsers
     */
    readonly perPage?: number | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly idEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly idNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly emailEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly emailNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly nameEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly nameNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly usernameEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly usernameNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceLte?: string | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceCurrencyEq?: Array<CurrencyRequest>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceCurrencyNeq?: Array<CurrencyRequest>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof UserApiGetAllUsers
     */
    readonly isAdminEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof UserApiGetAllUsers
     */
    readonly isAdminNeq?: boolean | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof UserApiGetAllUsers
     */
    readonly isBannedEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof UserApiGetAllUsers
     */
    readonly isBannedNeq?: boolean | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly createdAtEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly createdAtNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly createdAtGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly createdAtLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly createdAtGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly createdAtLte?: string | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly lastAccessAtEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly lastAccessAtNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly lastAccessAtGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly lastAccessAtLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly lastAccessAtGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly lastAccessAtLte?: string | null

    /**
     * Used for sorting the output
     * @type {Array<UserSortEnum>}
     * @memberof UserApiGetAllUsers
     */
    readonly sort?: Array<UserSortEnum>
}

/**
 * Request parameters for getUser operation in UserApi.
 * @export
 * @interface UserApiGetUserRequest
 */
export interface UserApiGetUserRequest {
    /**
     * The database ID of the user to retrieve.
     * @type {string}
     * @memberof UserApiGetUser
     */
    readonly id: string
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Returns an error if the user doesn\'t exist, if there is a validation issue, or if a database.
     * @summary Edit an existing user by ID.
     * @param {UserApiEditUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public editUser(requestParameters: UserApiEditUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).editUser(requestParameters.id, requestParameters.editUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of user per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of users.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view others users
     * @summary Handles the request to retrieve a paginated list of users.
     * @param {UserApiGetAllUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAllUsers(requestParameters: UserApiGetAllUsersRequest = {}, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getAllUsers(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.emailEq, requestParameters.emailNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.usernameEq, requestParameters.usernameNeq, requestParameters.balanceEq, requestParameters.balanceNeq, requestParameters.balanceGt, requestParameters.balanceLt, requestParameters.balanceGte, requestParameters.balanceLte, requestParameters.balanceCurrencyEq, requestParameters.balanceCurrencyNeq, requestParameters.isAdminEq, requestParameters.isAdminNeq, requestParameters.isBannedEq, requestParameters.isBannedNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.lastAccessAtEq, requestParameters.lastAccessAtNeq, requestParameters.lastAccessAtGt, requestParameters.lastAccessAtLt, requestParameters.lastAccessAtGte, requestParameters.lastAccessAtLte, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function is responsible for handling login requests. When a user attempts to access the login route, they are redirected to the frontend base URL specified in the application\'s configuration (command-line arguments or environment variables).  
     * @summary Handles the login route by redirecting the user to the frontend.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getLogin(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getLogin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function manages user logout by initiating an OIDC provider-initiated logout and then redirecting the user to the frontend base URL.
     * @summary Handles the logout process by initiating a logout request with the OIDC provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getLogout(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function checks if a user is authenticated using the optional `User`. If the user is logged in, their information (ID, username, email, etc...) is returned as a JSON response. If not logged in, it returns a `204 No Content` response, indicating the user is not authenticated.
     * @summary Handles the `/me` route, returning the current user\'s information if authenticated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMe(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Path Parameters**:   `id` (UUID): The database ID of the user to retrieve.  - **Response Codes**:   - `200 OK`: The user was successfully retrieved.   - `404 Not Found`: The user doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the user is disabled, only an admin can retrieve it.
     * @summary Handles the request to fetch a user by its unique identifier.
     * @param {UserApiGetUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(requestParameters: UserApiGetUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



