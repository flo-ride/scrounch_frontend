/* tslint:disable */
/* eslint-disable */
/**
 * api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Represents the request format for currency types in the API, enabling serialization and deserialization to/from lowercase strings.
 * @export
 * @enum {string}
 */

export const CurrencyRequest = {
    Euro: 'euro',
    Epicoin: 'epicoin'
} as const;

export type CurrencyRequest = typeof CurrencyRequest[keyof typeof CurrencyRequest];


/**
 * Represents the response format for currency types in the API, enabling serialization and deserialization to/from lowercase strings.
 * @export
 * @enum {string}
 */

export const CurrencyResponse = {
    Euro: 'euro',
    Epicoin: 'epicoin'
} as const;

export type CurrencyResponse = typeof CurrencyResponse[keyof typeof CurrencyResponse];


/**
 * Represents a request to editing an existing location, including necessary validation for name length and optional category.
 * @export
 * @interface EditLocationRequest
 */
export interface EditLocationRequest {
    /**
     * The category of the location, which may be optional.
     * @type {LocationCategoryRequest}
     * @memberof EditLocationRequest
     */
    'category'?: LocationCategoryRequest | null;
    /**
     * Optional field to disable or enable the location.
     * @type {boolean}
     * @memberof EditLocationRequest
     */
    'disabled'?: boolean | null;
    /**
     * Optional field to hide or show the location.
     * @type {boolean}
     * @memberof EditLocationRequest
     */
    'hidden'?: boolean | null;
    /**
     * The name of the location, subject to length validation.
     * @type {string}
     * @memberof EditLocationRequest
     */
    'name'?: string | null;
}


/**
 * Request structure for editing an existing product, allowing optional updates to fields.
 * @export
 * @interface EditProductRequest
 */
export interface EditProductRequest {
    /**
     * Optional field to disable or enable the product.
     * @type {boolean}
     * @memberof EditProductRequest
     */
    'disabled'?: boolean | null;
    /**
     * Display Order of the product inside of lists, 0 is last + default
     * @type {number}
     * @memberof EditProductRequest
     */
    'display_order'?: number | null;
    /**
     * Optional field to hide the product.
     * @type {boolean}
     * @memberof EditProductRequest
     */
    'hidden'?: boolean | null;
    /**
     * Optional image URL or path, which can also be set to `None`.
     * @type {string}
     * @memberof EditProductRequest
     */
    'image'?: string | null;
    /**
     * Optional Inventree IPN, can be `None` if specified.
     * @type {string}
     * @memberof EditProductRequest
     */
    'inventree_code'?: string | null;
    /**
     * Optional maximum quantity per command with conversion and size limits.
     * @type {number}
     * @memberof EditProductRequest
     */
    'max_quantity_per_command'?: number | null;
    /**
     * Optional name of the product with length validation.
     * @type {string}
     * @memberof EditProductRequest
     */
    'name'?: string | null;
    /**
     * If the product is purchasable or if it\'s just an ingredients
     * @type {boolean}
     * @memberof EditProductRequest
     */
    'purchasable'?: boolean | null;
    /**
     * Optional price of the product, required to be positive if present.
     * @type {number}
     * @memberof EditProductRequest
     */
    'sell_price'?: number | null;
    /**
     * Optional price of the product, required to be positive if present.
     * @type {CurrencyRequest}
     * @memberof EditProductRequest
     */
    'sell_price_currency'?: CurrencyRequest | null;
    /**
     * Optional SMA code for product identification, can be `None` if specified.
     * @type {string}
     * @memberof EditProductRequest
     */
    'sma_code'?: string | null;
    /**
     * Represent the unit type of Product, if it\'s a liquid -> Liter, etc..., the default is Unit
     * @type {UnitRequest}
     * @memberof EditProductRequest
     */
    'unit'?: UnitRequest | null;
}


/**
 * Request structure for editing an existing recipe, allowing optional updates to fields.
 * @export
 * @interface EditRecipeRequest
 */
export interface EditRecipeRequest {
    /**
     * Optional field to disable or enable the recipe.
     * @type {boolean}
     * @memberof EditRecipeRequest
     */
    'disabled'?: boolean | null;
    /**
     * List of ingredients
     * @type {Array<RecipeIngredientRequest>}
     * @memberof EditRecipeRequest
     */
    'ingredients': Array<RecipeIngredientRequest>;
    /**
     * Name of the recipe, required and validated for length.
     * @type {string}
     * @memberof EditRecipeRequest
     */
    'name'?: string | null;
    /**
     * Id of the resulting product
     * @type {string}
     * @memberof EditRecipeRequest
     */
    'product'?: string | null;
}
/**
 * Structure representing a request to edit an existing refill entry.
 * @export
 * @interface EditRefillRequest
 */
export interface EditRefillRequest {
    /**
     * Optional new amount for the refill.
     * @type {number}
     * @memberof EditRefillRequest
     */
    'credit'?: number | null;
    /**
     * Optional currency type for the new refill credit.
     * @type {CurrencyRequest}
     * @memberof EditRefillRequest
     */
    'credit_currency'?: CurrencyRequest | null;
    /**
     * Optional new disabled status for the refill.
     * @type {boolean}
     * @memberof EditRefillRequest
     */
    'disabled'?: boolean | null;
    /**
     * Optional hidden status for the refill.
     * @type {boolean}
     * @memberof EditRefillRequest
     */
    'hidden'?: boolean | null;
    /**
     * Optional new name for the refill.
     * @type {string}
     * @memberof EditRefillRequest
     */
    'name'?: string | null;
    /**
     * Optional new amount for the refill.
     * @type {number}
     * @memberof EditRefillRequest
     */
    'price'?: number | null;
    /**
     * Optional currency type for the new refill price.
     * @type {CurrencyRequest}
     * @memberof EditRefillRequest
     */
    'price_currency'?: CurrencyRequest | null;
}


/**
 * Represents an update request for user-specific fields, allowing modification of key boolean attributes such as `is_admin` and `is_banned`.
 * @export
 * @interface EditUserRequest
 */
export interface EditUserRequest {
    /**
     * Indicates whether the user has admin privileges.
     * @type {boolean}
     * @memberof EditUserRequest
     */
    'is_admin'?: boolean | null;
    /**
     * Indicates whether the user is banned from the system.
     * @type {boolean}
     * @memberof EditUserRequest
     */
    'is_banned'?: boolean | null;
}
/**
 * Structure representing a request to edit an existing warehouse entry.
 * @export
 * @interface EditWarehouseRequest
 */
export interface EditWarehouseRequest {
    /**
     * Optional new disabled status for the warehouse.
     * @type {boolean}
     * @memberof EditWarehouseRequest
     */
    'disabled'?: boolean | null;
    /**
     * New name for the Warehouse.
     * @type {string}
     * @memberof EditWarehouseRequest
     */
    'name'?: string | null;
}
/**
 * Response structure for edited product details.
 * @export
 * @interface EditedProductResponse
 */
export interface EditedProductResponse {
    /**
     * Optional flag indicating if the product is disabled.
     * @type {boolean}
     * @memberof EditedProductResponse
     */
    'disabled'?: boolean | null;
    /**
     * Unique identifier for the product.
     * @type {string}
     * @memberof EditedProductResponse
     */
    'id': string;
    /**
     * Optional image associated with the product.
     * @type {string}
     * @memberof EditedProductResponse
     */
    'image'?: string | null;
    /**
     * Optional maximum quantity allowed per command.
     * @type {number}
     * @memberof EditedProductResponse
     */
    'max_quantity_per_command'?: number | null;
    /**
     * Optional name of the product.
     * @type {string}
     * @memberof EditedProductResponse
     */
    'name'?: string | null;
    /**
     * Optional price of the product.
     * @type {number}
     * @memberof EditedProductResponse
     */
    'price'?: number | null;
    /**
     * Optional SMA code associated with the product.
     * @type {string}
     * @memberof EditedProductResponse
     */
    'sma_code'?: string | null;
}
/**
 * Represents a standardized error response returned by the API.  This struct is designed to provide structured error information to clients, including an HTTP status code, an error identifier, a category describing the error type, and a user-friendly error message.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * A brief string identifying the type of error.
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
    /**
     * The category or kind of the error, often used to classify error types.
     * @type {string}
     * @memberof ErrorResponse
     */
    'kind': string;
    /**
     * A descriptive message providing additional details about the error.
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * The HTTP status code associated with the error.
     * @type {number}
     * @memberof ErrorResponse
     */
    'status': number;
}
/**
 * Enum representing the different types of files.  This enum is used to differentiate between various types of file. It is deserialized from lowercase string values.
 * @export
 * @enum {string}
 */

export const FileType = {
    Product: 'product'
} as const;

export type FileType = typeof FileType[keyof typeof FileType];


/**
 * Enum representing categories of locations, such as dispensers or rooms. This type is used for deserializing request payloads.
 * @export
 * @enum {string}
 */

export const LocationCategoryRequest = {
    Dispenser: 'dispenser',
    Room: 'room'
} as const;

export type LocationCategoryRequest = typeof LocationCategoryRequest[keyof typeof LocationCategoryRequest];


/**
 * Enum representing categories of locations, such as dispensers or rooms. This type is used for serializing request payloads and indicates the type of location being referred to in a response.
 * @export
 * @enum {string}
 */

export const LocationCategoryResponse = {
    Dispenser: 'dispenser',
    Room: 'room'
} as const;

export type LocationCategoryResponse = typeof LocationCategoryResponse[keyof typeof LocationCategoryResponse];


/**
 * Response structure representing a paginated list of locations.  This structure is intended for use in API responses where a paginated list of locations is required.
 * @export
 * @interface LocationListResponse
 */
export interface LocationListResponse {
    /**
     * The current page number in the paginated response.
     * @type {number}
     * @memberof LocationListResponse
     */
    'current_page': number;
    /**
     * A list of locations on the current page, represented by `LocationResponse`.
     * @type {Array<LocationResponse>}
     * @memberof LocationListResponse
     */
    'locations': Array<LocationResponse>;
    /**
     * The total number of pages available.
     * @type {number}
     * @memberof LocationListResponse
     */
    'total_page': number;
}
/**
 * Response structure representing a location entity, including its unique identifier, name, category, creation timestamp, and status.  This structure is used for API responses where individual location details are required.
 * @export
 * @interface LocationResponse
 */
export interface LocationResponse {
    /**
     * The category of the location, which could be `Dispenser` or `Room`.
     * @type {LocationCategoryResponse}
     * @memberof LocationResponse
     */
    'category'?: LocationCategoryResponse | null;
    /**
     * The timestamp indicating when the location was created.
     * @type {string}
     * @memberof LocationResponse
     */
    'created_at': string;
    /**
     * Indicates whether the location is disabled.
     * @type {boolean}
     * @memberof LocationResponse
     */
    'disabled': boolean;
    /**
     * Indicates whether the location is hidden.
     * @type {boolean}
     * @memberof LocationResponse
     */
    'hidden'?: boolean | null;
    /**
     * Unique identifier of the location.
     * @type {string}
     * @memberof LocationResponse
     */
    'id': string;
    /**
     * The name of the location.
     * @type {string}
     * @memberof LocationResponse
     */
    'name': string;
}


/**
 * Generated by DeriveToSortQuery macro for flo_orm
 * @export
 * @enum {string}
 */

export const LocationSortEnum = {
    IdAsc: 'id_asc',
    IdDesc: 'id_desc',
    NameAsc: 'name_asc',
    NameDesc: 'name_desc',
    CreatedAtAsc: 'created_at_asc',
    CreatedAtDesc: 'created_at_desc',
    CategoryAsc: 'category_asc',
    CategoryDesc: 'category_desc',
    HiddenAsc: 'hidden_asc',
    HiddenDesc: 'hidden_desc',
    DisabledAsc: 'disabled_asc',
    DisabledDesc: 'disabled_desc'
} as const;

export type LocationSortEnum = typeof LocationSortEnum[keyof typeof LocationSortEnum];


/**
 * Represents a request to create a new location, including necessary validation for name length and optional category.
 * @export
 * @interface NewLocationRequest
 */
export interface NewLocationRequest {
    /**
     * The category of the location, which may be optional.
     * @type {LocationCategoryRequest}
     * @memberof NewLocationRequest
     */
    'category'?: LocationCategoryRequest | null;
    /**
     * The name of the location, subject to length validation.
     * @type {string}
     * @memberof NewLocationRequest
     */
    'name': string;
}


/**
 * Request structure for creating a new product, including validation rules.
 * @export
 * @interface NewProductRequest
 */
export interface NewProductRequest {
    /**
     * If the product is disabled from user (can\'t create new order with it)
     * @type {boolean}
     * @memberof NewProductRequest
     */
    'disabled'?: boolean | null;
    /**
     * If the product is hidden from user, if true, it\'s automatically disable
     * @type {boolean}
     * @memberof NewProductRequest
     */
    'hidden'?: boolean | null;
    /**
     * Optional image URL or path.
     * @type {string}
     * @memberof NewProductRequest
     */
    'image'?: string | null;
    /**
     * Optional Inventree IPN
     * @type {string}
     * @memberof NewProductRequest
     */
    'inventree_code'?: string | null;
    /**
     * Optional maximum quantity per command, limited to a certain maximum.
     * @type {number}
     * @memberof NewProductRequest
     */
    'max_quantity_per_command'?: number | null;
    /**
     * Name of the product, required and validated for length.
     * @type {string}
     * @memberof NewProductRequest
     */
    'name': string;
    /**
     * If the product is purchasable or if it\'s just an ingredients, if it\'s not it\'s automatically hidden
     * @type {boolean}
     * @memberof NewProductRequest
     */
    'purchasable'?: boolean | null;
    /**
     * Price of the product, required and must be positive.
     * @type {number}
     * @memberof NewProductRequest
     */
    'sell_price'?: number | null;
    /**
     * Currency of the product.
     * @type {CurrencyRequest}
     * @memberof NewProductRequest
     */
    'sell_price_currency'?: CurrencyRequest | null;
    /**
     * Optional SMA code for product identification.
     * @type {string}
     * @memberof NewProductRequest
     */
    'sma_code'?: string | null;
    /**
     * Represent the unit type of Product, if it\'s a liquid -> Liter, etc..., the default is Unit
     * @type {UnitRequest}
     * @memberof NewProductRequest
     */
    'unit'?: UnitRequest | null;
}


/**
 * Request structure for creating a new recipe, including validation rules.
 * @export
 * @interface NewRecipeRequest
 */
export interface NewRecipeRequest {
    /**
     * List of ingredients
     * @type {Array<RecipeIngredientRequest>}
     * @memberof NewRecipeRequest
     */
    'ingredients': Array<RecipeIngredientRequest>;
    /**
     * Name of the recipe, required and validated for length.
     * @type {string}
     * @memberof NewRecipeRequest
     */
    'name'?: string | null;
    /**
     * Id of the resulting product
     * @type {string}
     * @memberof NewRecipeRequest
     */
    'product': string;
}
/**
 * Request structure for creating a new refill, including validation rules.
 * @export
 * @interface NewRefillRequest
 */
export interface NewRefillRequest {
    /**
     * Amount given with refill
     * @type {number}
     * @memberof NewRefillRequest
     */
    'credit': number;
    /**
     * Currency type for the refill credit.
     * @type {CurrencyRequest}
     * @memberof NewRefillRequest
     */
    'credit_currency': CurrencyRequest;
    /**
     * Name of the refill, required and validated for length.
     * @type {string}
     * @memberof NewRefillRequest
     */
    'name'?: string | null;
    /**
     * Amount for buying refill
     * @type {number}
     * @memberof NewRefillRequest
     */
    'price': number;
    /**
     * Currency type for the refill price.
     * @type {CurrencyRequest}
     * @memberof NewRefillRequest
     */
    'price_currency': CurrencyRequest;
}


/**
 * Request structure for creating a new warehouse, including validation rules.
 * @export
 * @interface NewWarehouseProductRequest
 */
export interface NewWarehouseProductRequest {
    /**
     * Name of the warehouse, required and validated for length.
     * @type {string}
     * @memberof NewWarehouseProductRequest
     */
    'quantity': string;
}
/**
 * Request structure for creating a new warehouse, including validation rules.
 * @export
 * @interface NewWarehouseRequest
 */
export interface NewWarehouseRequest {
    /**
     * Name of the warehouse, required and validated for length.
     * @type {string}
     * @memberof NewWarehouseRequest
     */
    'name': string;
}
/**
 * Response structure for a list of products with pagination details.
 * @export
 * @interface ProductListResponse
 */
export interface ProductListResponse {
    /**
     * Current page number.
     * @type {number}
     * @memberof ProductListResponse
     */
    'current_page': number;
    /**
     * List of products on the current page.
     * @type {Array<ProductResponse>}
     * @memberof ProductListResponse
     */
    'products': Array<ProductResponse>;
    /**
     * Total number of pages available.
     * @type {number}
     * @memberof ProductListResponse
     */
    'total_page': number;
}
/**
 * Response structure for a product, including its details.
 * @export
 * @interface ProductResponse
 */
export interface ProductResponse {
    /**
     * Creation timestamp of the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'created_at': string;
    /**
     * indicating if the product is disabled.
     * @type {boolean}
     * @memberof ProductResponse
     */
    'disabled': boolean;
    /**
     * Display Order of the product.
     * @type {number}
     * @memberof ProductResponse
     */
    'display_order': number;
    /**
     * Is the product can be seen by simple user
     * @type {boolean}
     * @memberof ProductResponse
     */
    'hidden'?: boolean | null;
    /**
     * Unique identifier for the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'id': string;
    /**
     * Optional image associated with the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'image'?: string | null;
    /**
     * Optional Inventree IPN
     * @type {string}
     * @memberof ProductResponse
     */
    'inventree_code'?: string | null;
    /**
     * Optional maximum quantity allowed per command.
     * @type {number}
     * @memberof ProductResponse
     */
    'max_quantity_per_command'?: number | null;
    /**
     * Name of the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'name': string;
    /**
     * Is the product purchasable
     * @type {boolean}
     * @memberof ProductResponse
     */
    'purchasable'?: boolean | null;
    /**
     * Price of the product.
     * @type {number}
     * @memberof ProductResponse
     */
    'sell_price'?: number | null;
    /**
     * Currency of the product price.
     * @type {CurrencyResponse}
     * @memberof ProductResponse
     */
    'sell_price_currency'?: CurrencyResponse | null;
    /**
     * Optional SMA code associated with the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'sma_code'?: string | null;
    /**
     * Represent the unit type of Product, if it\'s a liquid -> Liter, etc...
     * @type {UnitResponse}
     * @memberof ProductResponse
     */
    'unit': UnitResponse;
}


/**
 * Generated by DeriveToSortQuery macro for flo_orm
 * @export
 * @enum {string}
 */

export const ProductSortEnum = {
    IdAsc: 'id_asc',
    IdDesc: 'id_desc',
    ImageAsc: 'image_asc',
    ImageDesc: 'image_desc',
    NameAsc: 'name_asc',
    NameDesc: 'name_desc',
    DisplayOrderAsc: 'display_order_asc',
    DisplayOrderDesc: 'display_order_desc',
    SellPriceAsc: 'sell_price_asc',
    SellPriceDesc: 'sell_price_desc',
    SellPriceCurrencyAsc: 'sell_price_currency_asc',
    SellPriceCurrencyDesc: 'sell_price_currency_desc',
    UnitAsc: 'unit_asc',
    UnitDesc: 'unit_desc',
    MaxQuantityPerCommandAsc: 'max_quantity_per_command_asc',
    MaxQuantityPerCommandDesc: 'max_quantity_per_command_desc',
    PurchasableAsc: 'purchasable_asc',
    PurchasableDesc: 'purchasable_desc',
    HiddenAsc: 'hidden_asc',
    HiddenDesc: 'hidden_desc',
    DisabledAsc: 'disabled_asc',
    DisabledDesc: 'disabled_desc',
    CreatedAtAsc: 'created_at_asc',
    CreatedAtDesc: 'created_at_desc',
    SmaCodeAsc: 'sma_code_asc',
    SmaCodeDesc: 'sma_code_desc',
    InventreeCodeAsc: 'inventree_code_asc',
    InventreeCodeDesc: 'inventree_code_desc'
} as const;

export type ProductSortEnum = typeof ProductSortEnum[keyof typeof ProductSortEnum];


/**
 * Request structure for creating a new recipe ingredient, including validation rules.
 * @export
 * @interface RecipeIngredientRequest
 */
export interface RecipeIngredientRequest {
    /**
     * Optional field to disable or enable the recipe.
     * @type {boolean}
     * @memberof RecipeIngredientRequest
     */
    'disabled'?: boolean | null;
    /**
     * Product id of the ingredient
     * @type {string}
     * @memberof RecipeIngredientRequest
     */
    'product': string;
    /**
     * Quantity of this product for the recipe
     * @type {number}
     * @memberof RecipeIngredientRequest
     */
    'quantity': number;
}
/**
 * Response structure for a recipe ingredient, including its details.
 * @export
 * @interface RecipeIngredientResponse
 */
export interface RecipeIngredientResponse {
    /**
     * indicating if the ingredient is disabled.
     * @type {boolean}
     * @memberof RecipeIngredientResponse
     */
    'disabled': boolean;
    /**
     * Product use for this ingredient
     * @type {string}
     * @memberof RecipeIngredientResponse
     */
    'product': string;
    /**
     * Quantity of this ingredient
     * @type {number}
     * @memberof RecipeIngredientResponse
     */
    'quantity': number;
}
/**
 * Response structure for a list of recipes with pagination details.
 * @export
 * @interface RecipeListResponse
 */
export interface RecipeListResponse {
    /**
     * Current page number.
     * @type {number}
     * @memberof RecipeListResponse
     */
    'current_page': number;
    /**
     * List of recipes on the current page.
     * @type {Array<RecipeResponse>}
     * @memberof RecipeListResponse
     */
    'recipes': Array<RecipeResponse>;
    /**
     * Total number of pages available.
     * @type {number}
     * @memberof RecipeListResponse
     */
    'total_page': number;
}
/**
 * Response structure for a recipe, including its details.
 * @export
 * @interface RecipeResponse
 */
export interface RecipeResponse {
    /**
     * The timestamp indicating when the recipe was created.
     * @type {string}
     * @memberof RecipeResponse
     */
    'created_at': string;
    /**
     * indicating if the recipe is disabled.
     * @type {boolean}
     * @memberof RecipeResponse
     */
    'disabled': boolean;
    /**
     * Unique identifier for the recipe.
     * @type {string}
     * @memberof RecipeResponse
     */
    'id': string;
    /**
     * List of ingredients
     * @type {Array<RecipeIngredientResponse>}
     * @memberof RecipeResponse
     */
    'ingredients': Array<RecipeIngredientResponse>;
    /**
     * Name of the recipe.
     * @type {string}
     * @memberof RecipeResponse
     */
    'name'?: string | null;
    /**
     * Resulting product of this recipe
     * @type {string}
     * @memberof RecipeResponse
     */
    'product': string;
}
/**
 * Generated by DeriveToSortQuery macro for flo_orm
 * @export
 * @enum {string}
 */

export const RecipeSortEnum = {
    IdAsc: 'id_asc',
    IdDesc: 'id_desc',
    ResultProductIdAsc: 'result_product_id_asc',
    ResultProductIdDesc: 'result_product_id_desc',
    NameAsc: 'name_asc',
    NameDesc: 'name_desc',
    DisabledAsc: 'disabled_asc',
    DisabledDesc: 'disabled_desc',
    CreatedAtAsc: 'created_at_asc',
    CreatedAtDesc: 'created_at_desc'
} as const;

export type RecipeSortEnum = typeof RecipeSortEnum[keyof typeof RecipeSortEnum];


/**
 * Represents a response containing a list of refills returned by the API.
 * @export
 * @interface RefillListResponse
 */
export interface RefillListResponse {
    /**
     * The current page number being viewed.
     * @type {number}
     * @memberof RefillListResponse
     */
    'current_page': number;
    /**
     * A list of refill responses containing refill details.
     * @type {Array<RefillResponse>}
     * @memberof RefillListResponse
     */
    'refills': Array<RefillResponse>;
    /**
     * The total number of pages available for refill results.
     * @type {number}
     * @memberof RefillListResponse
     */
    'total_page': number;
}
/**
 * Represents a response containing refill information returned by the API.
 * @export
 * @interface RefillResponse
 */
export interface RefillResponse {
    /**
     * The timestamp indicating when the refill was created.
     * @type {string}
     * @memberof RefillResponse
     */
    'created_at': string;
    /**
     * Credit of the refill.
     * @type {number}
     * @memberof RefillResponse
     */
    'credit': number;
    /**
     * Currency type for the refill credit.
     * @type {CurrencyResponse}
     * @memberof RefillResponse
     */
    'credit_currency': CurrencyResponse;
    /**
     * Indicates whether the refill is currently disabled.
     * @type {boolean}
     * @memberof RefillResponse
     */
    'disabled': boolean;
    /**
     * Indicates whether the refill is currently hidden.
     * @type {boolean}
     * @memberof RefillResponse
     */
    'hidden'?: boolean | null;
    /**
     * Unique identifier for the refill.
     * @type {string}
     * @memberof RefillResponse
     */
    'id': string;
    /**
     * The full name of the refill.
     * @type {string}
     * @memberof RefillResponse
     */
    'name'?: string | null;
    /**
     * Price of the refill.
     * @type {number}
     * @memberof RefillResponse
     */
    'price': number;
    /**
     * Currency type for the refill price.
     * @type {CurrencyResponse}
     * @memberof RefillResponse
     */
    'price_currency': CurrencyResponse;
}


/**
 * Generated by DeriveToSortQuery macro for flo_orm
 * @export
 * @enum {string}
 */

export const RefillSortEnum = {
    IdAsc: 'id_asc',
    IdDesc: 'id_desc',
    NameAsc: 'name_asc',
    NameDesc: 'name_desc',
    CreatedAtAsc: 'created_at_asc',
    CreatedAtDesc: 'created_at_desc',
    PriceAsc: 'price_asc',
    PriceDesc: 'price_desc',
    PriceCurrencyAsc: 'price_currency_asc',
    PriceCurrencyDesc: 'price_currency_desc',
    CreditAsc: 'credit_asc',
    CreditDesc: 'credit_desc',
    CreditCurrencyAsc: 'credit_currency_asc',
    CreditCurrencyDesc: 'credit_currency_desc',
    HiddenAsc: 'hidden_asc',
    HiddenDesc: 'hidden_desc',
    DisabledAsc: 'disabled_asc',
    DisabledDesc: 'disabled_desc'
} as const;

export type RefillSortEnum = typeof RefillSortEnum[keyof typeof RefillSortEnum];


/**
 * Represents the response structure for synchronizing products with the SMA system, categorizing products based on their synchronization status. This structure is intended for use in API responses where the status of products in relation to the SMA system needs to be clearly distinguished.
 * @export
 * @interface SmaResponse
 */
export interface SmaResponse {
    /**
     * A list of products that were updated, represented by `EditedProductResponse`.
     * @type {Array<EditedProductResponse>}
     * @memberof SmaResponse
     */
    'changed': Array<EditedProductResponse>;
    /**
     * A list of newly created products, represented by `ProductResponse`.
     * @type {Array<ProductResponse>}
     * @memberof SmaResponse
     */
    'created': Array<ProductResponse>;
    /**
     * A list of product IDs that have not been modified during the synchronization process.
     * @type {Array<string>}
     * @memberof SmaResponse
     */
    'unchanged': Array<string>;
}
/**
 * Represents the different type of Unit an Product or Else can have
 * @export
 * @enum {string}
 */

export const UnitRequest = {
    Unit: 'unit',
    Gram: 'gram',
    Liter: 'liter',
    Meter: 'meter'
} as const;

export type UnitRequest = typeof UnitRequest[keyof typeof UnitRequest];


/**
 * Represents the different type of Unit an Product or Else can have
 * @export
 * @enum {string}
 */

export const UnitResponse = {
    Unit: 'unit',
    Gram: 'gram',
    Liter: 'liter',
    Meter: 'meter'
} as const;

export type UnitResponse = typeof UnitResponse[keyof typeof UnitResponse];


/**
 * Represents a response containing a list of users returned by the API.
 * @export
 * @interface UserListResponse
 */
export interface UserListResponse {
    /**
     * The current page number being viewed.
     * @type {number}
     * @memberof UserListResponse
     */
    'current_page': number;
    /**
     * The total number of pages available for user results.
     * @type {number}
     * @memberof UserListResponse
     */
    'total_page': number;
    /**
     * A list of user responses containing user details.
     * @type {Array<UserResponse>}
     * @memberof UserListResponse
     */
    'users': Array<UserResponse>;
}
/**
 * Represents a response containing user information returned by the API.
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * The timestamp of when the user was created.
     * @type {string}
     * @memberof UserResponse
     */
    'created_at': string;
    /**
     * The email address of the user.
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string | null;
    /**
     * Unique identifier for the user.
     * @type {string}
     * @memberof UserResponse
     */
    'id': string;
    /**
     * Indicates whether the user has admin privileges.
     * @type {boolean}
     * @memberof UserResponse
     */
    'is_admin': boolean;
    /**
     * Indicates whether the user is banned from the application.
     * @type {boolean}
     * @memberof UserResponse
     */
    'is_banned': boolean;
    /**
     * The timestamp of the user\'s last access.
     * @type {string}
     * @memberof UserResponse
     */
    'last_access_at': string;
    /**
     * The full name of the user.
     * @type {string}
     * @memberof UserResponse
     */
    'name'?: string | null;
    /**
     * The username chosen by the user.
     * @type {string}
     * @memberof UserResponse
     */
    'username'?: string | null;
}
/**
 * Generated by DeriveToSortQuery macro for flo_orm
 * @export
 * @enum {string}
 */

export const UserSortEnum = {
    IdAsc: 'id_asc',
    IdDesc: 'id_desc',
    EmailAsc: 'email_asc',
    EmailDesc: 'email_desc',
    NameAsc: 'name_asc',
    NameDesc: 'name_desc',
    UsernameAsc: 'username_asc',
    UsernameDesc: 'username_desc',
    BalanceAsc: 'balance_asc',
    BalanceDesc: 'balance_desc',
    BalanceCurrencyAsc: 'balance_currency_asc',
    BalanceCurrencyDesc: 'balance_currency_desc',
    IsAdminAsc: 'is_admin_asc',
    IsAdminDesc: 'is_admin_desc',
    IsBannedAsc: 'is_banned_asc',
    IsBannedDesc: 'is_banned_desc',
    CreatedAtAsc: 'created_at_asc',
    CreatedAtDesc: 'created_at_desc',
    LastAccessAtAsc: 'last_access_at_asc',
    LastAccessAtDesc: 'last_access_at_desc'
} as const;

export type UserSortEnum = typeof UserSortEnum[keyof typeof UserSortEnum];


/**
 * Response structure for a list of warehouses with pagination details.
 * @export
 * @interface WarehouseListResponse
 */
export interface WarehouseListResponse {
    /**
     * Current page number.
     * @type {number}
     * @memberof WarehouseListResponse
     */
    'current_page': number;
    /**
     * Total number of pages available.
     * @type {number}
     * @memberof WarehouseListResponse
     */
    'total_page': number;
    /**
     * List of warehouses on the current page.
     * @type {Array<WarehouseResponse>}
     * @memberof WarehouseListResponse
     */
    'warehouses': Array<WarehouseResponse>;
}
/**
 * Represent a link between a Warehouse and a Product
 * @export
 * @interface WarehouseProductResponse
 */
export interface WarehouseProductResponse {
    /**
     * The timestamp indicating when the link was created.
     * @type {string}
     * @memberof WarehouseProductResponse
     */
    'created_at': string;
    /**
     * The product of this Warehouse
     * @type {ProductResponse}
     * @memberof WarehouseProductResponse
     */
    'product': ProductResponse;
    /**
     * The product quantity in this warehouse
     * @type {string}
     * @memberof WarehouseProductResponse
     */
    'quantity': string;
}
/**
 * Generated by DeriveToSortQuery macro for flo_orm
 * @export
 * @enum {string}
 */

export const WarehouseProductSortEnum = {
    WarehouseIdAsc: 'warehouse_id_asc',
    WarehouseIdDesc: 'warehouse_id_desc',
    ProductIdAsc: 'product_id_asc',
    ProductIdDesc: 'product_id_desc',
    QuantityAsc: 'quantity_asc',
    QuantityDesc: 'quantity_desc',
    CreatedAtAsc: 'created_at_asc',
    CreatedAtDesc: 'created_at_desc'
} as const;

export type WarehouseProductSortEnum = typeof WarehouseProductSortEnum[keyof typeof WarehouseProductSortEnum];


/**
 * Represent the lists of products for this Warehouse
 * @export
 * @interface WarehouseProductsListResponse
 */
export interface WarehouseProductsListResponse {
    /**
     * Current page number.
     * @type {number}
     * @memberof WarehouseProductsListResponse
     */
    'current_page': number;
    /**
     * The lists of products for this Warehouse
     * @type {Array<WarehouseProductResponse>}
     * @memberof WarehouseProductsListResponse
     */
    'products': Array<WarehouseProductResponse>;
    /**
     * Total number of pages available.
     * @type {number}
     * @memberof WarehouseProductsListResponse
     */
    'total_page': number;
}
/**
 * Response structure for a warehouse, including its details.
 * @export
 * @interface WarehouseResponse
 */
export interface WarehouseResponse {
    /**
     * The timestamp indicating when the warehouse was created.
     * @type {string}
     * @memberof WarehouseResponse
     */
    'created_at': string;
    /**
     * Indicates whether the warehouse is currently disabled.
     * @type {boolean}
     * @memberof WarehouseResponse
     */
    'disabled': boolean;
    /**
     * Unique identifier for the warehouse.
     * @type {string}
     * @memberof WarehouseResponse
     */
    'id': string;
    /**
     * Name of the warehouse.
     * @type {string}
     * @memberof WarehouseResponse
     */
    'name': string;
}
/**
 * Generated by DeriveToSortQuery macro for flo_orm
 * @export
 * @enum {string}
 */

export const WarehouseSortEnum = {
    IdAsc: 'id_asc',
    IdDesc: 'id_desc',
    NameAsc: 'name_asc',
    NameDesc: 'name_desc',
    DisabledAsc: 'disabled_asc',
    DisabledDesc: 'disabled_desc',
    CreatedAtAsc: 'created_at_asc',
    CreatedAtDesc: 'created_at_desc'
} as const;

export type WarehouseSortEnum = typeof WarehouseSortEnum[keyof typeof WarehouseSortEnum];



/**
 * LocationApi - axios parameter creator
 * @export
 */
export const LocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The location is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the location in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The location has been successfully disabled.
         * @summary Deletes a location by its database ID.
         * @param {string} id Location database id to delete location for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLocation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLocation', 'id', id)
            const localVarPath = `/location/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an error if the location doesn\'t exist, if there is a validation issue, or if a database.
         * @summary Edit an existing location by ID.
         * @param {string} id location database id to edit location for
         * @param {EditLocationRequest} editLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLocation: async (id: string, editLocationRequest: EditLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editLocation', 'id', id)
            // verify required parameter 'editLocationRequest' is not null or undefined
            assertParamExists('editLocation', 'editLocationRequest', editLocationRequest)
            const localVarPath = `/location/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of location per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of locations.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view hidden location
         * @summary Handles the request to retrieve a paginated list of locations.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<LocationCategoryRequest>} [categoryEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<LocationCategoryRequest>} [categoryNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [hiddenEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [hiddenNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<LocationSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLocations: async (page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, categoryEq?: Array<LocationCategoryRequest>, categoryNeq?: Array<LocationCategoryRequest>, hiddenEq?: boolean | null, hiddenNeq?: boolean | null, disabledEq?: boolean | null, disabledNeq?: boolean | null, sort?: Array<LocationSortEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (idEq) {
                localVarQueryParameter['id_eq'] = idEq;
            }

            if (idNeq) {
                localVarQueryParameter['id_neq'] = idNeq;
            }

            if (nameEq) {
                localVarQueryParameter['name_eq'] = nameEq;
            }

            if (nameNeq) {
                localVarQueryParameter['name_neq'] = nameNeq;
            }

            if (createdAtEq) {
                localVarQueryParameter['created_at_eq'] = createdAtEq;
            }

            if (createdAtNeq) {
                localVarQueryParameter['created_at_neq'] = createdAtNeq;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString() :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString() :
                    createdAtLt;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (categoryEq) {
                localVarQueryParameter['category_eq'] = categoryEq;
            }

            if (categoryNeq) {
                localVarQueryParameter['category_neq'] = categoryNeq;
            }

            if (hiddenEq !== undefined) {
                localVarQueryParameter['hidden_eq'] = hiddenEq;
            }

            if (hiddenNeq !== undefined) {
                localVarQueryParameter['hidden_neq'] = hiddenNeq;
            }

            if (disabledEq !== undefined) {
                localVarQueryParameter['disabled_eq'] = disabledEq;
            }

            if (disabledNeq !== undefined) {
                localVarQueryParameter['disabled_neq'] = disabledNeq;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the location to retrieve.  - **Response Codes**:   - `200 OK`: The location was successfully retrieved.   - `404 Not Found`: The location doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the location is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a location by its unique identifier.
         * @param {string} id The database ID of the location to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLocation', 'id', id)
            const localVarPath = `/location/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function allows an admin to create a new location by sending a POST request to the `/location` endpoint. The new location is validated and stored in the database. The image associated with the location is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the location\'s ID.  Path: `/location`  - **Request Body:** Expects a `NewLocation` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new location, returns the new location\'s ID as a string.
         * @summary Handler for creating a new location.
         * @param {NewLocationRequest} newLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewLocation: async (newLocationRequest: NewLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newLocationRequest' is not null or undefined
            assertParamExists('postNewLocation', 'newLocationRequest', newLocationRequest)
            const localVarPath = `/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationApi - functional programming interface
 * @export
 */
export const LocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationApiAxiosParamCreator(configuration)
    return {
        /**
         * The location is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the location in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The location has been successfully disabled.
         * @summary Deletes a location by its database ID.
         * @param {string} id Location database id to delete location for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLocation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLocation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.deleteLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an error if the location doesn\'t exist, if there is a validation issue, or if a database.
         * @summary Edit an existing location by ID.
         * @param {string} id location database id to edit location for
         * @param {EditLocationRequest} editLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editLocation(id: string, editLocationRequest: EditLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editLocation(id, editLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.editLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of location per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of locations.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view hidden location
         * @summary Handles the request to retrieve a paginated list of locations.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<LocationCategoryRequest>} [categoryEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<LocationCategoryRequest>} [categoryNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [hiddenEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [hiddenNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<LocationSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllLocations(page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, categoryEq?: Array<LocationCategoryRequest>, categoryNeq?: Array<LocationCategoryRequest>, hiddenEq?: boolean | null, hiddenNeq?: boolean | null, disabledEq?: boolean | null, disabledNeq?: boolean | null, sort?: Array<LocationSortEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllLocations(page, perPage, idEq, idNeq, nameEq, nameNeq, createdAtEq, createdAtNeq, createdAtGt, createdAtLt, createdAtGte, createdAtLte, categoryEq, categoryNeq, hiddenEq, hiddenNeq, disabledEq, disabledNeq, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.getAllLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the location to retrieve.  - **Response Codes**:   - `200 OK`: The location was successfully retrieved.   - `404 Not Found`: The location doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the location is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a location by its unique identifier.
         * @param {string} id The database ID of the location to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.getLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function allows an admin to create a new location by sending a POST request to the `/location` endpoint. The new location is validated and stored in the database. The image associated with the location is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the location\'s ID.  Path: `/location`  - **Request Body:** Expects a `NewLocation` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new location, returns the new location\'s ID as a string.
         * @summary Handler for creating a new location.
         * @param {NewLocationRequest} newLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNewLocation(newLocationRequest: NewLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNewLocation(newLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.postNewLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationApi - factory interface
 * @export
 */
export const LocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationApiFp(configuration)
    return {
        /**
         * The location is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the location in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The location has been successfully disabled.
         * @summary Deletes a location by its database ID.
         * @param {LocationApiDeleteLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLocation(requestParameters: LocationApiDeleteLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteLocation(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an error if the location doesn\'t exist, if there is a validation issue, or if a database.
         * @summary Edit an existing location by ID.
         * @param {LocationApiEditLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLocation(requestParameters: LocationApiEditLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editLocation(requestParameters.id, requestParameters.editLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of location per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of locations.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view hidden location
         * @summary Handles the request to retrieve a paginated list of locations.
         * @param {LocationApiGetAllLocationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLocations(requestParameters: LocationApiGetAllLocationsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<LocationListResponse> {
            return localVarFp.getAllLocations(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.categoryEq, requestParameters.categoryNeq, requestParameters.hiddenEq, requestParameters.hiddenNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the location to retrieve.  - **Response Codes**:   - `200 OK`: The location was successfully retrieved.   - `404 Not Found`: The location doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the location is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a location by its unique identifier.
         * @param {LocationApiGetLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocation(requestParameters: LocationApiGetLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LocationResponse> {
            return localVarFp.getLocation(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This function allows an admin to create a new location by sending a POST request to the `/location` endpoint. The new location is validated and stored in the database. The image associated with the location is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the location\'s ID.  Path: `/location`  - **Request Body:** Expects a `NewLocation` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new location, returns the new location\'s ID as a string.
         * @summary Handler for creating a new location.
         * @param {LocationApiPostNewLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewLocation(requestParameters: LocationApiPostNewLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postNewLocation(requestParameters.newLocationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteLocation operation in LocationApi.
 * @export
 * @interface LocationApiDeleteLocationRequest
 */
export interface LocationApiDeleteLocationRequest {
    /**
     * Location database id to delete location for
     * @type {string}
     * @memberof LocationApiDeleteLocation
     */
    readonly id: string
}

/**
 * Request parameters for editLocation operation in LocationApi.
 * @export
 * @interface LocationApiEditLocationRequest
 */
export interface LocationApiEditLocationRequest {
    /**
     * location database id to edit location for
     * @type {string}
     * @memberof LocationApiEditLocation
     */
    readonly id: string

    /**
     * 
     * @type {EditLocationRequest}
     * @memberof LocationApiEditLocation
     */
    readonly editLocationRequest: EditLocationRequest
}

/**
 * Request parameters for getAllLocations operation in LocationApi.
 * @export
 * @interface LocationApiGetAllLocationsRequest
 */
export interface LocationApiGetAllLocationsRequest {
    /**
     * The page number to retrieve, starting from 0.
     * @type {number}
     * @memberof LocationApiGetAllLocations
     */
    readonly page?: number | null

    /**
     * The number of items to return per page.
     * @type {number}
     * @memberof LocationApiGetAllLocations
     */
    readonly perPage?: number | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof LocationApiGetAllLocations
     */
    readonly idEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof LocationApiGetAllLocations
     */
    readonly idNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof LocationApiGetAllLocations
     */
    readonly nameEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof LocationApiGetAllLocations
     */
    readonly nameNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof LocationApiGetAllLocations
     */
    readonly createdAtEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof LocationApiGetAllLocations
     */
    readonly createdAtNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof LocationApiGetAllLocations
     */
    readonly createdAtGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof LocationApiGetAllLocations
     */
    readonly createdAtLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof LocationApiGetAllLocations
     */
    readonly createdAtGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof LocationApiGetAllLocations
     */
    readonly createdAtLte?: string | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<LocationCategoryRequest>}
     * @memberof LocationApiGetAllLocations
     */
    readonly categoryEq?: Array<LocationCategoryRequest>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<LocationCategoryRequest>}
     * @memberof LocationApiGetAllLocations
     */
    readonly categoryNeq?: Array<LocationCategoryRequest>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof LocationApiGetAllLocations
     */
    readonly hiddenEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof LocationApiGetAllLocations
     */
    readonly hiddenNeq?: boolean | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof LocationApiGetAllLocations
     */
    readonly disabledEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof LocationApiGetAllLocations
     */
    readonly disabledNeq?: boolean | null

    /**
     * Used for sorting the output
     * @type {Array<LocationSortEnum>}
     * @memberof LocationApiGetAllLocations
     */
    readonly sort?: Array<LocationSortEnum>
}

/**
 * Request parameters for getLocation operation in LocationApi.
 * @export
 * @interface LocationApiGetLocationRequest
 */
export interface LocationApiGetLocationRequest {
    /**
     * The database ID of the location to retrieve.
     * @type {string}
     * @memberof LocationApiGetLocation
     */
    readonly id: string
}

/**
 * Request parameters for postNewLocation operation in LocationApi.
 * @export
 * @interface LocationApiPostNewLocationRequest
 */
export interface LocationApiPostNewLocationRequest {
    /**
     * 
     * @type {NewLocationRequest}
     * @memberof LocationApiPostNewLocation
     */
    readonly newLocationRequest: NewLocationRequest
}

/**
 * LocationApi - object-oriented interface
 * @export
 * @class LocationApi
 * @extends {BaseAPI}
 */
export class LocationApi extends BaseAPI {
    /**
     * The location is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the location in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The location has been successfully disabled.
     * @summary Deletes a location by its database ID.
     * @param {LocationApiDeleteLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public deleteLocation(requestParameters: LocationApiDeleteLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).deleteLocation(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an error if the location doesn\'t exist, if there is a validation issue, or if a database.
     * @summary Edit an existing location by ID.
     * @param {LocationApiEditLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public editLocation(requestParameters: LocationApiEditLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).editLocation(requestParameters.id, requestParameters.editLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of location per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of locations.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view hidden location
     * @summary Handles the request to retrieve a paginated list of locations.
     * @param {LocationApiGetAllLocationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public getAllLocations(requestParameters: LocationApiGetAllLocationsRequest = {}, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).getAllLocations(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.categoryEq, requestParameters.categoryNeq, requestParameters.hiddenEq, requestParameters.hiddenNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Path Parameters**:   `id` (UUID): The database ID of the location to retrieve.  - **Response Codes**:   - `200 OK`: The location was successfully retrieved.   - `404 Not Found`: The location doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the location is hidden, only an admin can retrieve it.
     * @summary Handles the request to fetch a location by its unique identifier.
     * @param {LocationApiGetLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public getLocation(requestParameters: LocationApiGetLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).getLocation(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function allows an admin to create a new location by sending a POST request to the `/location` endpoint. The new location is validated and stored in the database. The image associated with the location is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the location\'s ID.  Path: `/location`  - **Request Body:** Expects a `NewLocation` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new location, returns the new location\'s ID as a string.
     * @summary Handler for creating a new location.
     * @param {LocationApiPostNewLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public postNewLocation(requestParameters: LocationApiPostNewLocationRequest, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).postNewLocation(requestParameters.newLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MiscApi - axios parameter creator
 * @export
 */
export const MiscApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This function retrieves a specified file based on the given filename and type, and streams it to the client. It also handles errors related to file access, returning appropriate HTTP status codes for various scenarios such as file not found or other errors.  # Parameters - `filename`: The name of the file to be downloaded. - `params`: The type of the file, which affects the download behavior.  # Responses - `200`: The file is correctly uploaded. - `400`: You\'re missing some field.  # Errors Returns an error if the file does not exist or if there is an issue with the S3 storage.
         * @summary Downloads files from the server\'s storage.
         * @param {string} filename The filename
         * @param {FileType} fileType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (filename: string, fileType: FileType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('downloadFile', 'filename', filename)
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('downloadFile', 'fileType', fileType)
            const localVarPath = `/download/{filename}`
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fileType !== undefined) {
                localVarQueryParameter['file_type'] = fileType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This asynchronous function handles the `/status` endpoint and returns a static string indicating that the server is running. It is commonly used for health checks to confirm that the application is up and operational.  # Returns A static string `\"UP\"`, representing the server\'s status.  # Endpoint - **GET /status**: Responds with `\"UP\"` and a `200 OK` status.
         * @summary Returns the status of the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Errors - Returns a 500 status code if there is an internal error, such as a failure to fetch or process Sma data. - Returns a 400 status code if the request to Sma is not correctly formatted.  # Responses - 200: The products have been successfully updated.
         * @summary Updates the local product database by importing products from the Sma API. This function retrieves the latest products from Sma, processes the data, and updates the local products accordingly.
         * @param {boolean} [name] Indicates if the product\&#39;s name has changed.
         * @param {boolean} [price] Indicates if the product\&#39;s price has changed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdateFromSma: async (name?: boolean, price?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sma`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows an admin user to upload files to a specified S3 bucket. It uses multipart form data to handle file uploads and stores them in a temporary S3 directory.
         * @summary Upload files
         * @param {FileType} fileType 
         * @param {File} file Represents the file data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUploadFiles: async (fileType: FileType, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('postUploadFiles', 'fileType', fileType)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('postUploadFiles', 'file', file)
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication axum-oidc required

            if (fileType !== undefined) {
                localVarQueryParameter['file_type'] = fileType;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscApi - functional programming interface
 * @export
 */
export const MiscApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscApiAxiosParamCreator(configuration)
    return {
        /**
         * This function retrieves a specified file based on the given filename and type, and streams it to the client. It also handles errors related to file access, returning appropriate HTTP status codes for various scenarios such as file not found or other errors.  # Parameters - `filename`: The name of the file to be downloaded. - `params`: The type of the file, which affects the download behavior.  # Responses - `200`: The file is correctly uploaded. - `400`: You\'re missing some field.  # Errors Returns an error if the file does not exist or if there is an issue with the S3 storage.
         * @summary Downloads files from the server\'s storage.
         * @param {string} filename The filename
         * @param {FileType} fileType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(filename: string, fileType: FileType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(filename, fileType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.downloadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This asynchronous function handles the `/status` endpoint and returns a static string indicating that the server is running. It is commonly used for health checks to confirm that the application is up and operational.  # Returns A static string `\"UP\"`, representing the server\'s status.  # Endpoint - **GET /status**: Responds with `\"UP\"` and a `200 OK` status.
         * @summary Returns the status of the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.getStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * # Errors - Returns a 500 status code if there is an internal error, such as a failure to fetch or process Sma data. - Returns a 400 status code if the request to Sma is not correctly formatted.  # Responses - 200: The products have been successfully updated.
         * @summary Updates the local product database by importing products from the Sma API. This function retrieves the latest products from Sma, processes the data, and updates the local products accordingly.
         * @param {boolean} [name] Indicates if the product\&#39;s name has changed.
         * @param {boolean} [price] Indicates if the product\&#39;s price has changed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdateFromSma(name?: boolean, price?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUpdateFromSma(name, price, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.postUpdateFromSma']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows an admin user to upload files to a specified S3 bucket. It uses multipart form data to handle file uploads and stores them in a temporary S3 directory.
         * @summary Upload files
         * @param {FileType} fileType 
         * @param {File} file Represents the file data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUploadFiles(fileType: FileType, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUploadFiles(fileType, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscApi.postUploadFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MiscApi - factory interface
 * @export
 */
export const MiscApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscApiFp(configuration)
    return {
        /**
         * This function retrieves a specified file based on the given filename and type, and streams it to the client. It also handles errors related to file access, returning appropriate HTTP status codes for various scenarios such as file not found or other errors.  # Parameters - `filename`: The name of the file to be downloaded. - `params`: The type of the file, which affects the download behavior.  # Responses - `200`: The file is correctly uploaded. - `400`: You\'re missing some field.  # Errors Returns an error if the file does not exist or if there is an issue with the S3 storage.
         * @summary Downloads files from the server\'s storage.
         * @param {MiscApiDownloadFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(requestParameters: MiscApiDownloadFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.downloadFile(requestParameters.filename, requestParameters.fileType, options).then((request) => request(axios, basePath));
        },
        /**
         * This asynchronous function handles the `/status` endpoint and returns a static string indicating that the server is running. It is commonly used for health checks to confirm that the application is up and operational.  # Returns A static string `\"UP\"`, representing the server\'s status.  # Endpoint - **GET /status**: Responds with `\"UP\"` and a `200 OK` status.
         * @summary Returns the status of the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * # Errors - Returns a 500 status code if there is an internal error, such as a failure to fetch or process Sma data. - Returns a 400 status code if the request to Sma is not correctly formatted.  # Responses - 200: The products have been successfully updated.
         * @summary Updates the local product database by importing products from the Sma API. This function retrieves the latest products from Sma, processes the data, and updates the local products accordingly.
         * @param {MiscApiPostUpdateFromSmaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdateFromSma(requestParameters: MiscApiPostUpdateFromSmaRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SmaResponse> {
            return localVarFp.postUpdateFromSma(requestParameters.name, requestParameters.price, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows an admin user to upload files to a specified S3 bucket. It uses multipart form data to handle file uploads and stores them in a temporary S3 directory.
         * @summary Upload files
         * @param {MiscApiPostUploadFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUploadFiles(requestParameters: MiscApiPostUploadFilesRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postUploadFiles(requestParameters.fileType, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadFile operation in MiscApi.
 * @export
 * @interface MiscApiDownloadFileRequest
 */
export interface MiscApiDownloadFileRequest {
    /**
     * The filename
     * @type {string}
     * @memberof MiscApiDownloadFile
     */
    readonly filename: string

    /**
     * 
     * @type {FileType}
     * @memberof MiscApiDownloadFile
     */
    readonly fileType: FileType
}

/**
 * Request parameters for postUpdateFromSma operation in MiscApi.
 * @export
 * @interface MiscApiPostUpdateFromSmaRequest
 */
export interface MiscApiPostUpdateFromSmaRequest {
    /**
     * Indicates if the product\&#39;s name has changed.
     * @type {boolean}
     * @memberof MiscApiPostUpdateFromSma
     */
    readonly name?: boolean

    /**
     * Indicates if the product\&#39;s price has changed.
     * @type {boolean}
     * @memberof MiscApiPostUpdateFromSma
     */
    readonly price?: boolean
}

/**
 * Request parameters for postUploadFiles operation in MiscApi.
 * @export
 * @interface MiscApiPostUploadFilesRequest
 */
export interface MiscApiPostUploadFilesRequest {
    /**
     * 
     * @type {FileType}
     * @memberof MiscApiPostUploadFiles
     */
    readonly fileType: FileType

    /**
     * Represents the file data
     * @type {File}
     * @memberof MiscApiPostUploadFiles
     */
    readonly file: File
}

/**
 * MiscApi - object-oriented interface
 * @export
 * @class MiscApi
 * @extends {BaseAPI}
 */
export class MiscApi extends BaseAPI {
    /**
     * This function retrieves a specified file based on the given filename and type, and streams it to the client. It also handles errors related to file access, returning appropriate HTTP status codes for various scenarios such as file not found or other errors.  # Parameters - `filename`: The name of the file to be downloaded. - `params`: The type of the file, which affects the download behavior.  # Responses - `200`: The file is correctly uploaded. - `400`: You\'re missing some field.  # Errors Returns an error if the file does not exist or if there is an issue with the S3 storage.
     * @summary Downloads files from the server\'s storage.
     * @param {MiscApiDownloadFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public downloadFile(requestParameters: MiscApiDownloadFileRequest, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).downloadFile(requestParameters.filename, requestParameters.fileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This asynchronous function handles the `/status` endpoint and returns a static string indicating that the server is running. It is commonly used for health checks to confirm that the application is up and operational.  # Returns A static string `\"UP\"`, representing the server\'s status.  # Endpoint - **GET /status**: Responds with `\"UP\"` and a `200 OK` status.
     * @summary Returns the status of the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public getStatus(options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Errors - Returns a 500 status code if there is an internal error, such as a failure to fetch or process Sma data. - Returns a 400 status code if the request to Sma is not correctly formatted.  # Responses - 200: The products have been successfully updated.
     * @summary Updates the local product database by importing products from the Sma API. This function retrieves the latest products from Sma, processes the data, and updates the local products accordingly.
     * @param {MiscApiPostUpdateFromSmaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public postUpdateFromSma(requestParameters: MiscApiPostUpdateFromSmaRequest = {}, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).postUpdateFromSma(requestParameters.name, requestParameters.price, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows an admin user to upload files to a specified S3 bucket. It uses multipart form data to handle file uploads and stores them in a temporary S3 directory.
     * @summary Upload files
     * @param {MiscApiPostUploadFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public postUploadFiles(requestParameters: MiscApiPostUploadFilesRequest, options?: RawAxiosRequestConfig) {
        return MiscApiFp(this.configuration).postUploadFiles(requestParameters.fileType, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The product is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the product in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The product has been successfully disabled.
         * @summary Deletes a product by its database ID.
         * @param {string} id Product database id to delete product for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProduct', 'id', id)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The admin can change attributes such as the name, price, quantity, or image of the product. If the product image is changed, the old image will be deleted from S3 storage.  Returns an error if the product doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing product by ID in the store.
         * @param {string} id Product database id to edit product for
         * @param {EditProductRequest} editProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProduct: async (id: string, editProductRequest: EditProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editProduct', 'id', id)
            // verify required parameter 'editProductRequest' is not null or undefined
            assertParamExists('editProduct', 'editProductRequest', editProductRequest)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of products per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of products.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see products that are not hidden.
         * @summary Handles the request to retrieve a paginated list of products.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [imageEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [imageNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<number>} [displayOrderEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<number>} [displayOrderNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {number | null} [displayOrderGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {number | null} [displayOrderLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {number | null} [displayOrderGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {number | null} [displayOrderLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [sellPriceEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [sellPriceNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<CurrencyRequest>} [sellPriceCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [sellPriceCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<UnitRequest>} [unitEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<UnitRequest>} [unitNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<number>} [maxQuantityPerCommandEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<number>} [maxQuantityPerCommandNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [purchasableEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [purchasableNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {boolean | null} [hiddenEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [hiddenNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [smaCodeEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [smaCodeNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [inventreeCodeEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [inventreeCodeNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<ProductSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts: async (page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, imageEq?: Array<string>, imageNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, displayOrderEq?: Array<number>, displayOrderNeq?: Array<number>, displayOrderGt?: number | null, displayOrderLt?: number | null, displayOrderGte?: number | null, displayOrderLte?: number | null, sellPriceEq?: Array<string>, sellPriceNeq?: Array<string>, sellPriceCurrencyEq?: Array<CurrencyRequest>, sellPriceCurrencyNeq?: Array<CurrencyRequest>, unitEq?: Array<UnitRequest>, unitNeq?: Array<UnitRequest>, maxQuantityPerCommandEq?: Array<number>, maxQuantityPerCommandNeq?: Array<number>, purchasableEq?: boolean | null, purchasableNeq?: boolean | null, hiddenEq?: boolean | null, hiddenNeq?: boolean | null, disabledEq?: boolean | null, disabledNeq?: boolean | null, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, smaCodeEq?: Array<string>, smaCodeNeq?: Array<string>, inventreeCodeEq?: Array<string>, inventreeCodeNeq?: Array<string>, sort?: Array<ProductSortEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (idEq) {
                localVarQueryParameter['id_eq'] = idEq;
            }

            if (idNeq) {
                localVarQueryParameter['id_neq'] = idNeq;
            }

            if (imageEq) {
                localVarQueryParameter['image_eq'] = imageEq;
            }

            if (imageNeq) {
                localVarQueryParameter['image_neq'] = imageNeq;
            }

            if (nameEq) {
                localVarQueryParameter['name_eq'] = nameEq;
            }

            if (nameNeq) {
                localVarQueryParameter['name_neq'] = nameNeq;
            }

            if (displayOrderEq) {
                localVarQueryParameter['display_order_eq'] = displayOrderEq;
            }

            if (displayOrderNeq) {
                localVarQueryParameter['display_order_neq'] = displayOrderNeq;
            }

            if (displayOrderGt !== undefined) {
                localVarQueryParameter['display_order_gt'] = displayOrderGt;
            }

            if (displayOrderLt !== undefined) {
                localVarQueryParameter['display_order_lt'] = displayOrderLt;
            }

            if (displayOrderGte !== undefined) {
                localVarQueryParameter['display_order_gte'] = displayOrderGte;
            }

            if (displayOrderLte !== undefined) {
                localVarQueryParameter['display_order_lte'] = displayOrderLte;
            }

            if (sellPriceEq) {
                localVarQueryParameter['sell_price_eq'] = sellPriceEq;
            }

            if (sellPriceNeq) {
                localVarQueryParameter['sell_price_neq'] = sellPriceNeq;
            }

            if (sellPriceCurrencyEq) {
                localVarQueryParameter['sell_price_currency_eq'] = sellPriceCurrencyEq;
            }

            if (sellPriceCurrencyNeq) {
                localVarQueryParameter['sell_price_currency_neq'] = sellPriceCurrencyNeq;
            }

            if (unitEq) {
                localVarQueryParameter['unit_eq'] = unitEq;
            }

            if (unitNeq) {
                localVarQueryParameter['unit_neq'] = unitNeq;
            }

            if (maxQuantityPerCommandEq) {
                localVarQueryParameter['max_quantity_per_command_eq'] = maxQuantityPerCommandEq;
            }

            if (maxQuantityPerCommandNeq) {
                localVarQueryParameter['max_quantity_per_command_neq'] = maxQuantityPerCommandNeq;
            }

            if (purchasableEq !== undefined) {
                localVarQueryParameter['purchasable_eq'] = purchasableEq;
            }

            if (purchasableNeq !== undefined) {
                localVarQueryParameter['purchasable_neq'] = purchasableNeq;
            }

            if (hiddenEq !== undefined) {
                localVarQueryParameter['hidden_eq'] = hiddenEq;
            }

            if (hiddenNeq !== undefined) {
                localVarQueryParameter['hidden_neq'] = hiddenNeq;
            }

            if (disabledEq !== undefined) {
                localVarQueryParameter['disabled_eq'] = disabledEq;
            }

            if (disabledNeq !== undefined) {
                localVarQueryParameter['disabled_neq'] = disabledNeq;
            }

            if (createdAtEq) {
                localVarQueryParameter['created_at_eq'] = createdAtEq;
            }

            if (createdAtNeq) {
                localVarQueryParameter['created_at_neq'] = createdAtNeq;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString() :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString() :
                    createdAtLt;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (smaCodeEq) {
                localVarQueryParameter['sma_code_eq'] = smaCodeEq;
            }

            if (smaCodeNeq) {
                localVarQueryParameter['sma_code_neq'] = smaCodeNeq;
            }

            if (inventreeCodeEq) {
                localVarQueryParameter['inventree_code_eq'] = inventreeCodeEq;
            }

            if (inventreeCodeNeq) {
                localVarQueryParameter['inventree_code_neq'] = inventreeCodeNeq;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the product to retrieve.  - **Response Codes**:   - `200 OK`: The product was successfully retrieved.   - `404 Not Found`: The product doesn\'t exist, or is disabled and the requester is not an admin.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the product is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a product by its unique identifier.
         * @param {string} id The database ID of the product to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProduct', 'id', id)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function allows an admin to create a new product by sending a POST request to the `/product` endpoint. The new product is validated and stored in the database. The image associated with the product is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the product\'s ID.  Path: `/product`  - **Request Body:** Expects a `NewProduct` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new product, returns the new product\'s ID as a string.
         * @summary Handler for creating a new product.
         * @param {NewProductRequest} newProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewProduct: async (newProductRequest: NewProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newProductRequest' is not null or undefined
            assertParamExists('postNewProduct', 'newProductRequest', newProductRequest)
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * The product is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the product in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The product has been successfully disabled.
         * @summary Deletes a product by its database ID.
         * @param {string} id Product database id to delete product for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.deleteProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The admin can change attributes such as the name, price, quantity, or image of the product. If the product image is changed, the old image will be deleted from S3 storage.  Returns an error if the product doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing product by ID in the store.
         * @param {string} id Product database id to edit product for
         * @param {EditProductRequest} editProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProduct(id: string, editProductRequest: EditProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProduct(id, editProductRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.editProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of products per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of products.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see products that are not hidden.
         * @summary Handles the request to retrieve a paginated list of products.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [imageEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [imageNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<number>} [displayOrderEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<number>} [displayOrderNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {number | null} [displayOrderGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {number | null} [displayOrderLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {number | null} [displayOrderGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {number | null} [displayOrderLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [sellPriceEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [sellPriceNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<CurrencyRequest>} [sellPriceCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [sellPriceCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<UnitRequest>} [unitEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<UnitRequest>} [unitNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<number>} [maxQuantityPerCommandEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<number>} [maxQuantityPerCommandNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [purchasableEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [purchasableNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {boolean | null} [hiddenEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [hiddenNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [smaCodeEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [smaCodeNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [inventreeCodeEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [inventreeCodeNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<ProductSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProducts(page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, imageEq?: Array<string>, imageNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, displayOrderEq?: Array<number>, displayOrderNeq?: Array<number>, displayOrderGt?: number | null, displayOrderLt?: number | null, displayOrderGte?: number | null, displayOrderLte?: number | null, sellPriceEq?: Array<string>, sellPriceNeq?: Array<string>, sellPriceCurrencyEq?: Array<CurrencyRequest>, sellPriceCurrencyNeq?: Array<CurrencyRequest>, unitEq?: Array<UnitRequest>, unitNeq?: Array<UnitRequest>, maxQuantityPerCommandEq?: Array<number>, maxQuantityPerCommandNeq?: Array<number>, purchasableEq?: boolean | null, purchasableNeq?: boolean | null, hiddenEq?: boolean | null, hiddenNeq?: boolean | null, disabledEq?: boolean | null, disabledNeq?: boolean | null, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, smaCodeEq?: Array<string>, smaCodeNeq?: Array<string>, inventreeCodeEq?: Array<string>, inventreeCodeNeq?: Array<string>, sort?: Array<ProductSortEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProducts(page, perPage, idEq, idNeq, imageEq, imageNeq, nameEq, nameNeq, displayOrderEq, displayOrderNeq, displayOrderGt, displayOrderLt, displayOrderGte, displayOrderLte, sellPriceEq, sellPriceNeq, sellPriceCurrencyEq, sellPriceCurrencyNeq, unitEq, unitNeq, maxQuantityPerCommandEq, maxQuantityPerCommandNeq, purchasableEq, purchasableNeq, hiddenEq, hiddenNeq, disabledEq, disabledNeq, createdAtEq, createdAtNeq, createdAtGt, createdAtLt, createdAtGte, createdAtLte, smaCodeEq, smaCodeNeq, inventreeCodeEq, inventreeCodeNeq, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.getAllProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the product to retrieve.  - **Response Codes**:   - `200 OK`: The product was successfully retrieved.   - `404 Not Found`: The product doesn\'t exist, or is disabled and the requester is not an admin.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the product is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a product by its unique identifier.
         * @param {string} id The database ID of the product to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.getProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function allows an admin to create a new product by sending a POST request to the `/product` endpoint. The new product is validated and stored in the database. The image associated with the product is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the product\'s ID.  Path: `/product`  - **Request Body:** Expects a `NewProduct` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new product, returns the new product\'s ID as a string.
         * @summary Handler for creating a new product.
         * @param {NewProductRequest} newProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNewProduct(newProductRequest: NewProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNewProduct(newProductRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.postNewProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * The product is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the product in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The product has been successfully disabled.
         * @summary Deletes a product by its database ID.
         * @param {ProductApiDeleteProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(requestParameters: ProductApiDeleteProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProduct(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * The admin can change attributes such as the name, price, quantity, or image of the product. If the product image is changed, the old image will be deleted from S3 storage.  Returns an error if the product doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing product by ID in the store.
         * @param {ProductApiEditProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProduct(requestParameters: ProductApiEditProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editProduct(requestParameters.id, requestParameters.editProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of products per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of products.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see products that are not hidden.
         * @summary Handles the request to retrieve a paginated list of products.
         * @param {ProductApiGetAllProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(requestParameters: ProductApiGetAllProductsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ProductListResponse> {
            return localVarFp.getAllProducts(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.imageEq, requestParameters.imageNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.displayOrderEq, requestParameters.displayOrderNeq, requestParameters.displayOrderGt, requestParameters.displayOrderLt, requestParameters.displayOrderGte, requestParameters.displayOrderLte, requestParameters.sellPriceEq, requestParameters.sellPriceNeq, requestParameters.sellPriceCurrencyEq, requestParameters.sellPriceCurrencyNeq, requestParameters.unitEq, requestParameters.unitNeq, requestParameters.maxQuantityPerCommandEq, requestParameters.maxQuantityPerCommandNeq, requestParameters.purchasableEq, requestParameters.purchasableNeq, requestParameters.hiddenEq, requestParameters.hiddenNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.smaCodeEq, requestParameters.smaCodeNeq, requestParameters.inventreeCodeEq, requestParameters.inventreeCodeNeq, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the product to retrieve.  - **Response Codes**:   - `200 OK`: The product was successfully retrieved.   - `404 Not Found`: The product doesn\'t exist, or is disabled and the requester is not an admin.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the product is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a product by its unique identifier.
         * @param {ProductApiGetProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(requestParameters: ProductApiGetProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductResponse> {
            return localVarFp.getProduct(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This function allows an admin to create a new product by sending a POST request to the `/product` endpoint. The new product is validated and stored in the database. The image associated with the product is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the product\'s ID.  Path: `/product`  - **Request Body:** Expects a `NewProduct` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new product, returns the new product\'s ID as a string.
         * @summary Handler for creating a new product.
         * @param {ProductApiPostNewProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewProduct(requestParameters: ProductApiPostNewProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postNewProduct(requestParameters.newProductRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteProduct operation in ProductApi.
 * @export
 * @interface ProductApiDeleteProductRequest
 */
export interface ProductApiDeleteProductRequest {
    /**
     * Product database id to delete product for
     * @type {string}
     * @memberof ProductApiDeleteProduct
     */
    readonly id: string
}

/**
 * Request parameters for editProduct operation in ProductApi.
 * @export
 * @interface ProductApiEditProductRequest
 */
export interface ProductApiEditProductRequest {
    /**
     * Product database id to edit product for
     * @type {string}
     * @memberof ProductApiEditProduct
     */
    readonly id: string

    /**
     * 
     * @type {EditProductRequest}
     * @memberof ProductApiEditProduct
     */
    readonly editProductRequest: EditProductRequest
}

/**
 * Request parameters for getAllProducts operation in ProductApi.
 * @export
 * @interface ProductApiGetAllProductsRequest
 */
export interface ProductApiGetAllProductsRequest {
    /**
     * The page number to retrieve, starting from 0.
     * @type {number}
     * @memberof ProductApiGetAllProducts
     */
    readonly page?: number | null

    /**
     * The number of items to return per page.
     * @type {number}
     * @memberof ProductApiGetAllProducts
     */
    readonly perPage?: number | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly idEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly idNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly imageEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly imageNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly nameEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly nameNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<number>}
     * @memberof ProductApiGetAllProducts
     */
    readonly displayOrderEq?: Array<number>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<number>}
     * @memberof ProductApiGetAllProducts
     */
    readonly displayOrderNeq?: Array<number>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {number}
     * @memberof ProductApiGetAllProducts
     */
    readonly displayOrderGt?: number | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {number}
     * @memberof ProductApiGetAllProducts
     */
    readonly displayOrderLt?: number | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {number}
     * @memberof ProductApiGetAllProducts
     */
    readonly displayOrderGte?: number | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {number}
     * @memberof ProductApiGetAllProducts
     */
    readonly displayOrderLte?: number | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly sellPriceEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly sellPriceNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof ProductApiGetAllProducts
     */
    readonly sellPriceCurrencyEq?: Array<CurrencyRequest>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof ProductApiGetAllProducts
     */
    readonly sellPriceCurrencyNeq?: Array<CurrencyRequest>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<UnitRequest>}
     * @memberof ProductApiGetAllProducts
     */
    readonly unitEq?: Array<UnitRequest>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<UnitRequest>}
     * @memberof ProductApiGetAllProducts
     */
    readonly unitNeq?: Array<UnitRequest>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<number>}
     * @memberof ProductApiGetAllProducts
     */
    readonly maxQuantityPerCommandEq?: Array<number>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<number>}
     * @memberof ProductApiGetAllProducts
     */
    readonly maxQuantityPerCommandNeq?: Array<number>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof ProductApiGetAllProducts
     */
    readonly purchasableEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof ProductApiGetAllProducts
     */
    readonly purchasableNeq?: boolean | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof ProductApiGetAllProducts
     */
    readonly hiddenEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof ProductApiGetAllProducts
     */
    readonly hiddenNeq?: boolean | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof ProductApiGetAllProducts
     */
    readonly disabledEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof ProductApiGetAllProducts
     */
    readonly disabledNeq?: boolean | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly createdAtEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly createdAtNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof ProductApiGetAllProducts
     */
    readonly createdAtGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof ProductApiGetAllProducts
     */
    readonly createdAtLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof ProductApiGetAllProducts
     */
    readonly createdAtGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof ProductApiGetAllProducts
     */
    readonly createdAtLte?: string | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly smaCodeEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly smaCodeNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly inventreeCodeEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof ProductApiGetAllProducts
     */
    readonly inventreeCodeNeq?: Array<string>

    /**
     * Used for sorting the output
     * @type {Array<ProductSortEnum>}
     * @memberof ProductApiGetAllProducts
     */
    readonly sort?: Array<ProductSortEnum>
}

/**
 * Request parameters for getProduct operation in ProductApi.
 * @export
 * @interface ProductApiGetProductRequest
 */
export interface ProductApiGetProductRequest {
    /**
     * The database ID of the product to retrieve.
     * @type {string}
     * @memberof ProductApiGetProduct
     */
    readonly id: string
}

/**
 * Request parameters for postNewProduct operation in ProductApi.
 * @export
 * @interface ProductApiPostNewProductRequest
 */
export interface ProductApiPostNewProductRequest {
    /**
     * 
     * @type {NewProductRequest}
     * @memberof ProductApiPostNewProduct
     */
    readonly newProductRequest: NewProductRequest
}

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * The product is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the product in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The product has been successfully disabled.
     * @summary Deletes a product by its database ID.
     * @param {ProductApiDeleteProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public deleteProduct(requestParameters: ProductApiDeleteProductRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).deleteProduct(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The admin can change attributes such as the name, price, quantity, or image of the product. If the product image is changed, the old image will be deleted from S3 storage.  Returns an error if the product doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
     * @summary Edit an existing product by ID in the store.
     * @param {ProductApiEditProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public editProduct(requestParameters: ProductApiEditProductRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).editProduct(requestParameters.id, requestParameters.editProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of products per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of products.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see products that are not hidden.
     * @summary Handles the request to retrieve a paginated list of products.
     * @param {ProductApiGetAllProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getAllProducts(requestParameters: ProductApiGetAllProductsRequest = {}, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).getAllProducts(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.imageEq, requestParameters.imageNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.displayOrderEq, requestParameters.displayOrderNeq, requestParameters.displayOrderGt, requestParameters.displayOrderLt, requestParameters.displayOrderGte, requestParameters.displayOrderLte, requestParameters.sellPriceEq, requestParameters.sellPriceNeq, requestParameters.sellPriceCurrencyEq, requestParameters.sellPriceCurrencyNeq, requestParameters.unitEq, requestParameters.unitNeq, requestParameters.maxQuantityPerCommandEq, requestParameters.maxQuantityPerCommandNeq, requestParameters.purchasableEq, requestParameters.purchasableNeq, requestParameters.hiddenEq, requestParameters.hiddenNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.smaCodeEq, requestParameters.smaCodeNeq, requestParameters.inventreeCodeEq, requestParameters.inventreeCodeNeq, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Path Parameters**:   `id` (UUID): The database ID of the product to retrieve.  - **Response Codes**:   - `200 OK`: The product was successfully retrieved.   - `404 Not Found`: The product doesn\'t exist, or is disabled and the requester is not an admin.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the product is hidden, only an admin can retrieve it.
     * @summary Handles the request to fetch a product by its unique identifier.
     * @param {ProductApiGetProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProduct(requestParameters: ProductApiGetProductRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).getProduct(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function allows an admin to create a new product by sending a POST request to the `/product` endpoint. The new product is validated and stored in the database. The image associated with the product is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the product\'s ID.  Path: `/product`  - **Request Body:** Expects a `NewProduct` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new product, returns the new product\'s ID as a string.
     * @summary Handler for creating a new product.
     * @param {ProductApiPostNewProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public postNewProduct(requestParameters: ProductApiPostNewProductRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).postNewProduct(requestParameters.newProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RecipeApi - axios parameter creator
 * @export
 */
export const RecipeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The recipe is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the recipe in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The recipe has been successfully disabled.
         * @summary Deletes a recipe by its database ID.
         * @param {string} id Recipe database id to delete recipe for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRecipe', 'id', id)
            const localVarPath = `/recipe/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The admin can change attributes such as the name, price, quantity, or image of the recipe. If the recipe image is changed, the old image will be deleted from S3 storage.  Returns an error if the recipe doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing recipe by ID in the store.
         * @param {string} id Recipe database id to edit recipe for
         * @param {EditRecipeRequest} editRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRecipe: async (id: string, editRecipeRequest: EditRecipeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editRecipe', 'id', id)
            // verify required parameter 'editRecipeRequest' is not null or undefined
            assertParamExists('editRecipe', 'editRecipeRequest', editRecipeRequest)
            const localVarPath = `/recipe/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editRecipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of recipes per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of recipes.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see recipes that are not hidden.
         * @summary Handles the request to retrieve a paginated list of recipes.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {string | null} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {string | null} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [resultProductIdEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [resultProductIdNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<RecipeSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRecipes: async (page?: number | null, perPage?: number | null, idEq?: string | null, idNeq?: string | null, resultProductIdEq?: Array<string>, resultProductIdNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, disabledEq?: boolean | null, disabledNeq?: boolean | null, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, sort?: Array<RecipeSortEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recipe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (idEq !== undefined) {
                localVarQueryParameter['id_eq'] = idEq;
            }

            if (idNeq !== undefined) {
                localVarQueryParameter['id_neq'] = idNeq;
            }

            if (resultProductIdEq) {
                localVarQueryParameter['result_product_id_eq'] = resultProductIdEq;
            }

            if (resultProductIdNeq) {
                localVarQueryParameter['result_product_id_neq'] = resultProductIdNeq;
            }

            if (nameEq) {
                localVarQueryParameter['name_eq'] = nameEq;
            }

            if (nameNeq) {
                localVarQueryParameter['name_neq'] = nameNeq;
            }

            if (disabledEq !== undefined) {
                localVarQueryParameter['disabled_eq'] = disabledEq;
            }

            if (disabledNeq !== undefined) {
                localVarQueryParameter['disabled_neq'] = disabledNeq;
            }

            if (createdAtEq) {
                localVarQueryParameter['created_at_eq'] = createdAtEq;
            }

            if (createdAtNeq) {
                localVarQueryParameter['created_at_neq'] = createdAtNeq;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString() :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString() :
                    createdAtLt;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the recipe to retrieve.  - **Response Codes**:   - `200 OK`: The recipe was successfully retrieved.   - `404 Not Found`: The recipe doesn\'t exist, or is disabled and the requester is not an admin.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the recipe is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a recipe by its unique identifier.
         * @param {string} id The database ID of the recipe to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipe: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRecipe', 'id', id)
            const localVarPath = `/recipe/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function allows an admin to create a new recipe by sending a POST request to the `/recipe` endpoint. The new recipe is validated and stored in the database. The image associated with the recipe is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the recipe\'s ID.  Path: `/recipe`  - **Request Body:** Expects a `NewRecipe` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new recipe, returns the new recipe\'s ID as a string.
         * @summary Handler for creating a new recipe.
         * @param {NewRecipeRequest} newRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewRecipe: async (newRecipeRequest: NewRecipeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newRecipeRequest' is not null or undefined
            assertParamExists('postNewRecipe', 'newRecipeRequest', newRecipeRequest)
            const localVarPath = `/recipe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newRecipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecipeApi - functional programming interface
 * @export
 */
export const RecipeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecipeApiAxiosParamCreator(configuration)
    return {
        /**
         * The recipe is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the recipe in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The recipe has been successfully disabled.
         * @summary Deletes a recipe by its database ID.
         * @param {string} id Recipe database id to delete recipe for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecipe(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecipe(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipeApi.deleteRecipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The admin can change attributes such as the name, price, quantity, or image of the recipe. If the recipe image is changed, the old image will be deleted from S3 storage.  Returns an error if the recipe doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing recipe by ID in the store.
         * @param {string} id Recipe database id to edit recipe for
         * @param {EditRecipeRequest} editRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editRecipe(id: string, editRecipeRequest: EditRecipeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editRecipe(id, editRecipeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipeApi.editRecipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of recipes per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of recipes.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see recipes that are not hidden.
         * @summary Handles the request to retrieve a paginated list of recipes.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {string | null} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {string | null} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [resultProductIdEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [resultProductIdNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<RecipeSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRecipes(page?: number | null, perPage?: number | null, idEq?: string | null, idNeq?: string | null, resultProductIdEq?: Array<string>, resultProductIdNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, disabledEq?: boolean | null, disabledNeq?: boolean | null, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, sort?: Array<RecipeSortEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRecipes(page, perPage, idEq, idNeq, resultProductIdEq, resultProductIdNeq, nameEq, nameNeq, disabledEq, disabledNeq, createdAtEq, createdAtNeq, createdAtGt, createdAtLt, createdAtGte, createdAtLte, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipeApi.getAllRecipes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the recipe to retrieve.  - **Response Codes**:   - `200 OK`: The recipe was successfully retrieved.   - `404 Not Found`: The recipe doesn\'t exist, or is disabled and the requester is not an admin.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the recipe is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a recipe by its unique identifier.
         * @param {string} id The database ID of the recipe to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecipe(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecipe(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipeApi.getRecipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function allows an admin to create a new recipe by sending a POST request to the `/recipe` endpoint. The new recipe is validated and stored in the database. The image associated with the recipe is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the recipe\'s ID.  Path: `/recipe`  - **Request Body:** Expects a `NewRecipe` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new recipe, returns the new recipe\'s ID as a string.
         * @summary Handler for creating a new recipe.
         * @param {NewRecipeRequest} newRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNewRecipe(newRecipeRequest: NewRecipeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNewRecipe(newRecipeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipeApi.postNewRecipe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RecipeApi - factory interface
 * @export
 */
export const RecipeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecipeApiFp(configuration)
    return {
        /**
         * The recipe is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the recipe in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The recipe has been successfully disabled.
         * @summary Deletes a recipe by its database ID.
         * @param {RecipeApiDeleteRecipeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe(requestParameters: RecipeApiDeleteRecipeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRecipe(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * The admin can change attributes such as the name, price, quantity, or image of the recipe. If the recipe image is changed, the old image will be deleted from S3 storage.  Returns an error if the recipe doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing recipe by ID in the store.
         * @param {RecipeApiEditRecipeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRecipe(requestParameters: RecipeApiEditRecipeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editRecipe(requestParameters.id, requestParameters.editRecipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of recipes per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of recipes.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see recipes that are not hidden.
         * @summary Handles the request to retrieve a paginated list of recipes.
         * @param {RecipeApiGetAllRecipesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRecipes(requestParameters: RecipeApiGetAllRecipesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<RecipeListResponse> {
            return localVarFp.getAllRecipes(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.resultProductIdEq, requestParameters.resultProductIdNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the recipe to retrieve.  - **Response Codes**:   - `200 OK`: The recipe was successfully retrieved.   - `404 Not Found`: The recipe doesn\'t exist, or is disabled and the requester is not an admin.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the recipe is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a recipe by its unique identifier.
         * @param {RecipeApiGetRecipeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipe(requestParameters: RecipeApiGetRecipeRequest, options?: RawAxiosRequestConfig): AxiosPromise<RecipeResponse> {
            return localVarFp.getRecipe(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This function allows an admin to create a new recipe by sending a POST request to the `/recipe` endpoint. The new recipe is validated and stored in the database. The image associated with the recipe is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the recipe\'s ID.  Path: `/recipe`  - **Request Body:** Expects a `NewRecipe` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new recipe, returns the new recipe\'s ID as a string.
         * @summary Handler for creating a new recipe.
         * @param {RecipeApiPostNewRecipeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewRecipe(requestParameters: RecipeApiPostNewRecipeRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postNewRecipe(requestParameters.newRecipeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteRecipe operation in RecipeApi.
 * @export
 * @interface RecipeApiDeleteRecipeRequest
 */
export interface RecipeApiDeleteRecipeRequest {
    /**
     * Recipe database id to delete recipe for
     * @type {string}
     * @memberof RecipeApiDeleteRecipe
     */
    readonly id: string
}

/**
 * Request parameters for editRecipe operation in RecipeApi.
 * @export
 * @interface RecipeApiEditRecipeRequest
 */
export interface RecipeApiEditRecipeRequest {
    /**
     * Recipe database id to edit recipe for
     * @type {string}
     * @memberof RecipeApiEditRecipe
     */
    readonly id: string

    /**
     * 
     * @type {EditRecipeRequest}
     * @memberof RecipeApiEditRecipe
     */
    readonly editRecipeRequest: EditRecipeRequest
}

/**
 * Request parameters for getAllRecipes operation in RecipeApi.
 * @export
 * @interface RecipeApiGetAllRecipesRequest
 */
export interface RecipeApiGetAllRecipesRequest {
    /**
     * The page number to retrieve, starting from 0.
     * @type {number}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly page?: number | null

    /**
     * The number of items to return per page.
     * @type {number}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly perPage?: number | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {string}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly idEq?: string | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {string}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly idNeq?: string | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly resultProductIdEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly resultProductIdNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly nameEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly nameNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly disabledEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly disabledNeq?: boolean | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly createdAtEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly createdAtNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly createdAtGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly createdAtLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly createdAtGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly createdAtLte?: string | null

    /**
     * Used for sorting the output
     * @type {Array<RecipeSortEnum>}
     * @memberof RecipeApiGetAllRecipes
     */
    readonly sort?: Array<RecipeSortEnum>
}

/**
 * Request parameters for getRecipe operation in RecipeApi.
 * @export
 * @interface RecipeApiGetRecipeRequest
 */
export interface RecipeApiGetRecipeRequest {
    /**
     * The database ID of the recipe to retrieve.
     * @type {string}
     * @memberof RecipeApiGetRecipe
     */
    readonly id: string
}

/**
 * Request parameters for postNewRecipe operation in RecipeApi.
 * @export
 * @interface RecipeApiPostNewRecipeRequest
 */
export interface RecipeApiPostNewRecipeRequest {
    /**
     * 
     * @type {NewRecipeRequest}
     * @memberof RecipeApiPostNewRecipe
     */
    readonly newRecipeRequest: NewRecipeRequest
}

/**
 * RecipeApi - object-oriented interface
 * @export
 * @class RecipeApi
 * @extends {BaseAPI}
 */
export class RecipeApi extends BaseAPI {
    /**
     * The recipe is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the recipe in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The recipe has been successfully disabled.
     * @summary Deletes a recipe by its database ID.
     * @param {RecipeApiDeleteRecipeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public deleteRecipe(requestParameters: RecipeApiDeleteRecipeRequest, options?: RawAxiosRequestConfig) {
        return RecipeApiFp(this.configuration).deleteRecipe(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The admin can change attributes such as the name, price, quantity, or image of the recipe. If the recipe image is changed, the old image will be deleted from S3 storage.  Returns an error if the recipe doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
     * @summary Edit an existing recipe by ID in the store.
     * @param {RecipeApiEditRecipeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public editRecipe(requestParameters: RecipeApiEditRecipeRequest, options?: RawAxiosRequestConfig) {
        return RecipeApiFp(this.configuration).editRecipe(requestParameters.id, requestParameters.editRecipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of recipes per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of recipes.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see recipes that are not hidden.
     * @summary Handles the request to retrieve a paginated list of recipes.
     * @param {RecipeApiGetAllRecipesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public getAllRecipes(requestParameters: RecipeApiGetAllRecipesRequest = {}, options?: RawAxiosRequestConfig) {
        return RecipeApiFp(this.configuration).getAllRecipes(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.resultProductIdEq, requestParameters.resultProductIdNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Path Parameters**:   `id` (UUID): The database ID of the recipe to retrieve.  - **Response Codes**:   - `200 OK`: The recipe was successfully retrieved.   - `404 Not Found`: The recipe doesn\'t exist, or is disabled and the requester is not an admin.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the recipe is hidden, only an admin can retrieve it.
     * @summary Handles the request to fetch a recipe by its unique identifier.
     * @param {RecipeApiGetRecipeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public getRecipe(requestParameters: RecipeApiGetRecipeRequest, options?: RawAxiosRequestConfig) {
        return RecipeApiFp(this.configuration).getRecipe(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function allows an admin to create a new recipe by sending a POST request to the `/recipe` endpoint. The new recipe is validated and stored in the database. The image associated with the recipe is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the recipe\'s ID.  Path: `/recipe`  - **Request Body:** Expects a `NewRecipe` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new recipe, returns the new recipe\'s ID as a string.
     * @summary Handler for creating a new recipe.
     * @param {RecipeApiPostNewRecipeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public postNewRecipe(requestParameters: RecipeApiPostNewRecipeRequest, options?: RawAxiosRequestConfig) {
        return RecipeApiFp(this.configuration).postNewRecipe(requestParameters.newRecipeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RefillApi - axios parameter creator
 * @export
 */
export const RefillApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The refill is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the refill in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The refill has been successfully disabled.
         * @summary Deletes a refill by its database ID.
         * @param {string} id refill database id to delete refill for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRefill: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRefill', 'id', id)
            const localVarPath = `/refill/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The admin can change attributes such as the name, amont_in_euro, amont_in_epicoin of the refill.  Returns an error if the refill doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing refill by ID in the store.
         * @param {string} id refill database id to edit refill for
         * @param {EditRefillRequest} editRefillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRefill: async (id: string, editRefillRequest: EditRefillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editRefill', 'id', id)
            // verify required parameter 'editRefillRequest' is not null or undefined
            assertParamExists('editRefill', 'editRefillRequest', editRefillRequest)
            const localVarPath = `/refill/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editRefillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of refill per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of refills.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view hidden refill
         * @summary Handles the request to retrieve a paginated list of refills.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [priceEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [priceNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<CurrencyRequest>} [priceCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [priceCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [creditEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [creditNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<CurrencyRequest>} [creditCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [creditCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [hiddenEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [hiddenNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<RefillSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRefills: async (page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, priceEq?: Array<string>, priceNeq?: Array<string>, priceCurrencyEq?: Array<CurrencyRequest>, priceCurrencyNeq?: Array<CurrencyRequest>, creditEq?: Array<string>, creditNeq?: Array<string>, creditCurrencyEq?: Array<CurrencyRequest>, creditCurrencyNeq?: Array<CurrencyRequest>, hiddenEq?: boolean | null, hiddenNeq?: boolean | null, disabledEq?: boolean | null, disabledNeq?: boolean | null, sort?: Array<RefillSortEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/refill`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (idEq) {
                localVarQueryParameter['id_eq'] = idEq;
            }

            if (idNeq) {
                localVarQueryParameter['id_neq'] = idNeq;
            }

            if (nameEq) {
                localVarQueryParameter['name_eq'] = nameEq;
            }

            if (nameNeq) {
                localVarQueryParameter['name_neq'] = nameNeq;
            }

            if (createdAtEq) {
                localVarQueryParameter['created_at_eq'] = createdAtEq;
            }

            if (createdAtNeq) {
                localVarQueryParameter['created_at_neq'] = createdAtNeq;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString() :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString() :
                    createdAtLt;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (priceEq) {
                localVarQueryParameter['price_eq'] = priceEq;
            }

            if (priceNeq) {
                localVarQueryParameter['price_neq'] = priceNeq;
            }

            if (priceCurrencyEq) {
                localVarQueryParameter['price_currency_eq'] = priceCurrencyEq;
            }

            if (priceCurrencyNeq) {
                localVarQueryParameter['price_currency_neq'] = priceCurrencyNeq;
            }

            if (creditEq) {
                localVarQueryParameter['credit_eq'] = creditEq;
            }

            if (creditNeq) {
                localVarQueryParameter['credit_neq'] = creditNeq;
            }

            if (creditCurrencyEq) {
                localVarQueryParameter['credit_currency_eq'] = creditCurrencyEq;
            }

            if (creditCurrencyNeq) {
                localVarQueryParameter['credit_currency_neq'] = creditCurrencyNeq;
            }

            if (hiddenEq !== undefined) {
                localVarQueryParameter['hidden_eq'] = hiddenEq;
            }

            if (hiddenNeq !== undefined) {
                localVarQueryParameter['hidden_neq'] = hiddenNeq;
            }

            if (disabledEq !== undefined) {
                localVarQueryParameter['disabled_eq'] = disabledEq;
            }

            if (disabledNeq !== undefined) {
                localVarQueryParameter['disabled_neq'] = disabledNeq;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the refill to retrieve.  - **Response Codes**:   - `200 OK`: The refill was successfully retrieved.   - `404 Not Found`: The refill doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the refill is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a refill by its unique identifier.
         * @param {string} id The database ID of the refill to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefill: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRefill', 'id', id)
            const localVarPath = `/refill/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function allows an admin to create a new refill by sending a POST request to the `/refill` endpoint. The new refill is validated and stored in the database. The image associated with the refill is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the refill\'s ID.  Path: `/refill`  - **Request Body:** Expects a `NewRefill` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new refill, returns the new refill\'s ID as a string.
         * @summary Handler for creating a new refill.
         * @param {NewRefillRequest} newRefillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewRefill: async (newRefillRequest: NewRefillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newRefillRequest' is not null or undefined
            assertParamExists('postNewRefill', 'newRefillRequest', newRefillRequest)
            const localVarPath = `/refill`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newRefillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefillApi - functional programming interface
 * @export
 */
export const RefillApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefillApiAxiosParamCreator(configuration)
    return {
        /**
         * The refill is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the refill in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The refill has been successfully disabled.
         * @summary Deletes a refill by its database ID.
         * @param {string} id refill database id to delete refill for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRefill(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRefill(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillApi.deleteRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The admin can change attributes such as the name, amont_in_euro, amont_in_epicoin of the refill.  Returns an error if the refill doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing refill by ID in the store.
         * @param {string} id refill database id to edit refill for
         * @param {EditRefillRequest} editRefillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editRefill(id: string, editRefillRequest: EditRefillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editRefill(id, editRefillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillApi.editRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of refill per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of refills.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view hidden refill
         * @summary Handles the request to retrieve a paginated list of refills.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [priceEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [priceNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<CurrencyRequest>} [priceCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [priceCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [creditEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [creditNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<CurrencyRequest>} [creditCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [creditCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [hiddenEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [hiddenNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<RefillSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRefills(page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, priceEq?: Array<string>, priceNeq?: Array<string>, priceCurrencyEq?: Array<CurrencyRequest>, priceCurrencyNeq?: Array<CurrencyRequest>, creditEq?: Array<string>, creditNeq?: Array<string>, creditCurrencyEq?: Array<CurrencyRequest>, creditCurrencyNeq?: Array<CurrencyRequest>, hiddenEq?: boolean | null, hiddenNeq?: boolean | null, disabledEq?: boolean | null, disabledNeq?: boolean | null, sort?: Array<RefillSortEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefillListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRefills(page, perPage, idEq, idNeq, nameEq, nameNeq, createdAtEq, createdAtNeq, createdAtGt, createdAtLt, createdAtGte, createdAtLte, priceEq, priceNeq, priceCurrencyEq, priceCurrencyNeq, creditEq, creditNeq, creditCurrencyEq, creditCurrencyNeq, hiddenEq, hiddenNeq, disabledEq, disabledNeq, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillApi.getAllRefills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the refill to retrieve.  - **Response Codes**:   - `200 OK`: The refill was successfully retrieved.   - `404 Not Found`: The refill doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the refill is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a refill by its unique identifier.
         * @param {string} id The database ID of the refill to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRefill(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefillResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRefill(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillApi.getRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function allows an admin to create a new refill by sending a POST request to the `/refill` endpoint. The new refill is validated and stored in the database. The image associated with the refill is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the refill\'s ID.  Path: `/refill`  - **Request Body:** Expects a `NewRefill` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new refill, returns the new refill\'s ID as a string.
         * @summary Handler for creating a new refill.
         * @param {NewRefillRequest} newRefillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNewRefill(newRefillRequest: NewRefillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNewRefill(newRefillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillApi.postNewRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RefillApi - factory interface
 * @export
 */
export const RefillApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefillApiFp(configuration)
    return {
        /**
         * The refill is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the refill in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The refill has been successfully disabled.
         * @summary Deletes a refill by its database ID.
         * @param {RefillApiDeleteRefillRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRefill(requestParameters: RefillApiDeleteRefillRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRefill(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * The admin can change attributes such as the name, amont_in_euro, amont_in_epicoin of the refill.  Returns an error if the refill doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing refill by ID in the store.
         * @param {RefillApiEditRefillRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRefill(requestParameters: RefillApiEditRefillRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editRefill(requestParameters.id, requestParameters.editRefillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of refill per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of refills.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view hidden refill
         * @summary Handles the request to retrieve a paginated list of refills.
         * @param {RefillApiGetAllRefillsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRefills(requestParameters: RefillApiGetAllRefillsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<RefillListResponse> {
            return localVarFp.getAllRefills(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.priceEq, requestParameters.priceNeq, requestParameters.priceCurrencyEq, requestParameters.priceCurrencyNeq, requestParameters.creditEq, requestParameters.creditNeq, requestParameters.creditCurrencyEq, requestParameters.creditCurrencyNeq, requestParameters.hiddenEq, requestParameters.hiddenNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the refill to retrieve.  - **Response Codes**:   - `200 OK`: The refill was successfully retrieved.   - `404 Not Found`: The refill doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the refill is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a refill by its unique identifier.
         * @param {RefillApiGetRefillRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefill(requestParameters: RefillApiGetRefillRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefillResponse> {
            return localVarFp.getRefill(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This function allows an admin to create a new refill by sending a POST request to the `/refill` endpoint. The new refill is validated and stored in the database. The image associated with the refill is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the refill\'s ID.  Path: `/refill`  - **Request Body:** Expects a `NewRefill` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new refill, returns the new refill\'s ID as a string.
         * @summary Handler for creating a new refill.
         * @param {RefillApiPostNewRefillRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewRefill(requestParameters: RefillApiPostNewRefillRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postNewRefill(requestParameters.newRefillRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteRefill operation in RefillApi.
 * @export
 * @interface RefillApiDeleteRefillRequest
 */
export interface RefillApiDeleteRefillRequest {
    /**
     * refill database id to delete refill for
     * @type {string}
     * @memberof RefillApiDeleteRefill
     */
    readonly id: string
}

/**
 * Request parameters for editRefill operation in RefillApi.
 * @export
 * @interface RefillApiEditRefillRequest
 */
export interface RefillApiEditRefillRequest {
    /**
     * refill database id to edit refill for
     * @type {string}
     * @memberof RefillApiEditRefill
     */
    readonly id: string

    /**
     * 
     * @type {EditRefillRequest}
     * @memberof RefillApiEditRefill
     */
    readonly editRefillRequest: EditRefillRequest
}

/**
 * Request parameters for getAllRefills operation in RefillApi.
 * @export
 * @interface RefillApiGetAllRefillsRequest
 */
export interface RefillApiGetAllRefillsRequest {
    /**
     * The page number to retrieve, starting from 0.
     * @type {number}
     * @memberof RefillApiGetAllRefills
     */
    readonly page?: number | null

    /**
     * The number of items to return per page.
     * @type {number}
     * @memberof RefillApiGetAllRefills
     */
    readonly perPage?: number | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly idEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly idNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly nameEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly nameNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly createdAtEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly createdAtNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof RefillApiGetAllRefills
     */
    readonly createdAtGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof RefillApiGetAllRefills
     */
    readonly createdAtLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof RefillApiGetAllRefills
     */
    readonly createdAtGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof RefillApiGetAllRefills
     */
    readonly createdAtLte?: string | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly priceEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly priceNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof RefillApiGetAllRefills
     */
    readonly priceCurrencyEq?: Array<CurrencyRequest>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof RefillApiGetAllRefills
     */
    readonly priceCurrencyNeq?: Array<CurrencyRequest>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly creditEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof RefillApiGetAllRefills
     */
    readonly creditNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof RefillApiGetAllRefills
     */
    readonly creditCurrencyEq?: Array<CurrencyRequest>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof RefillApiGetAllRefills
     */
    readonly creditCurrencyNeq?: Array<CurrencyRequest>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof RefillApiGetAllRefills
     */
    readonly hiddenEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof RefillApiGetAllRefills
     */
    readonly hiddenNeq?: boolean | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof RefillApiGetAllRefills
     */
    readonly disabledEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof RefillApiGetAllRefills
     */
    readonly disabledNeq?: boolean | null

    /**
     * Used for sorting the output
     * @type {Array<RefillSortEnum>}
     * @memberof RefillApiGetAllRefills
     */
    readonly sort?: Array<RefillSortEnum>
}

/**
 * Request parameters for getRefill operation in RefillApi.
 * @export
 * @interface RefillApiGetRefillRequest
 */
export interface RefillApiGetRefillRequest {
    /**
     * The database ID of the refill to retrieve.
     * @type {string}
     * @memberof RefillApiGetRefill
     */
    readonly id: string
}

/**
 * Request parameters for postNewRefill operation in RefillApi.
 * @export
 * @interface RefillApiPostNewRefillRequest
 */
export interface RefillApiPostNewRefillRequest {
    /**
     * 
     * @type {NewRefillRequest}
     * @memberof RefillApiPostNewRefill
     */
    readonly newRefillRequest: NewRefillRequest
}

/**
 * RefillApi - object-oriented interface
 * @export
 * @class RefillApi
 * @extends {BaseAPI}
 */
export class RefillApi extends BaseAPI {
    /**
     * The refill is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the refill in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The refill has been successfully disabled.
     * @summary Deletes a refill by its database ID.
     * @param {RefillApiDeleteRefillRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillApi
     */
    public deleteRefill(requestParameters: RefillApiDeleteRefillRequest, options?: RawAxiosRequestConfig) {
        return RefillApiFp(this.configuration).deleteRefill(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The admin can change attributes such as the name, amont_in_euro, amont_in_epicoin of the refill.  Returns an error if the refill doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
     * @summary Edit an existing refill by ID in the store.
     * @param {RefillApiEditRefillRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillApi
     */
    public editRefill(requestParameters: RefillApiEditRefillRequest, options?: RawAxiosRequestConfig) {
        return RefillApiFp(this.configuration).editRefill(requestParameters.id, requestParameters.editRefillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of refill per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of refills.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view hidden refill
     * @summary Handles the request to retrieve a paginated list of refills.
     * @param {RefillApiGetAllRefillsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillApi
     */
    public getAllRefills(requestParameters: RefillApiGetAllRefillsRequest = {}, options?: RawAxiosRequestConfig) {
        return RefillApiFp(this.configuration).getAllRefills(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.priceEq, requestParameters.priceNeq, requestParameters.priceCurrencyEq, requestParameters.priceCurrencyNeq, requestParameters.creditEq, requestParameters.creditNeq, requestParameters.creditCurrencyEq, requestParameters.creditCurrencyNeq, requestParameters.hiddenEq, requestParameters.hiddenNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Path Parameters**:   `id` (UUID): The database ID of the refill to retrieve.  - **Response Codes**:   - `200 OK`: The refill was successfully retrieved.   - `404 Not Found`: The refill doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the refill is hidden, only an admin can retrieve it.
     * @summary Handles the request to fetch a refill by its unique identifier.
     * @param {RefillApiGetRefillRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillApi
     */
    public getRefill(requestParameters: RefillApiGetRefillRequest, options?: RawAxiosRequestConfig) {
        return RefillApiFp(this.configuration).getRefill(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function allows an admin to create a new refill by sending a POST request to the `/refill` endpoint. The new refill is validated and stored in the database. The image associated with the refill is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the refill\'s ID.  Path: `/refill`  - **Request Body:** Expects a `NewRefill` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new refill, returns the new refill\'s ID as a string.
     * @summary Handler for creating a new refill.
     * @param {RefillApiPostNewRefillRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillApi
     */
    public postNewRefill(requestParameters: RefillApiPostNewRefillRequest, options?: RawAxiosRequestConfig) {
        return RefillApiFp(this.configuration).postNewRefill(requestParameters.newRefillRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an error if the user doesn\'t exist, if there is a validation issue, or if a database.
         * @summary Edit an existing user by ID.
         * @param {string} id user database id to edit user for
         * @param {EditUserRequest} editUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser: async (id: string, editUserRequest: EditUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editUser', 'id', id)
            // verify required parameter 'editUserRequest' is not null or undefined
            assertParamExists('editUser', 'editUserRequest', editUserRequest)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of user per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of users.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view others users
         * @summary Handles the request to retrieve a paginated list of users.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [emailEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [emailNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [usernameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [usernameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [balanceEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [balanceNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [balanceGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [balanceLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [balanceGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [balanceLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<CurrencyRequest>} [balanceCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [balanceCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [isAdminEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [isAdminNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {boolean | null} [isBannedEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [isBannedNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [lastAccessAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [lastAccessAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [lastAccessAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [lastAccessAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [lastAccessAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [lastAccessAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<UserSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, emailEq?: Array<string>, emailNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, usernameEq?: Array<string>, usernameNeq?: Array<string>, balanceEq?: Array<string>, balanceNeq?: Array<string>, balanceGt?: string | null, balanceLt?: string | null, balanceGte?: string | null, balanceLte?: string | null, balanceCurrencyEq?: Array<CurrencyRequest>, balanceCurrencyNeq?: Array<CurrencyRequest>, isAdminEq?: boolean | null, isAdminNeq?: boolean | null, isBannedEq?: boolean | null, isBannedNeq?: boolean | null, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, lastAccessAtEq?: Array<string>, lastAccessAtNeq?: Array<string>, lastAccessAtGt?: string | null, lastAccessAtLt?: string | null, lastAccessAtGte?: string | null, lastAccessAtLte?: string | null, sort?: Array<UserSortEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (idEq) {
                localVarQueryParameter['id_eq'] = idEq;
            }

            if (idNeq) {
                localVarQueryParameter['id_neq'] = idNeq;
            }

            if (emailEq) {
                localVarQueryParameter['email_eq'] = emailEq;
            }

            if (emailNeq) {
                localVarQueryParameter['email_neq'] = emailNeq;
            }

            if (nameEq) {
                localVarQueryParameter['name_eq'] = nameEq;
            }

            if (nameNeq) {
                localVarQueryParameter['name_neq'] = nameNeq;
            }

            if (usernameEq) {
                localVarQueryParameter['username_eq'] = usernameEq;
            }

            if (usernameNeq) {
                localVarQueryParameter['username_neq'] = usernameNeq;
            }

            if (balanceEq) {
                localVarQueryParameter['balance_eq'] = balanceEq;
            }

            if (balanceNeq) {
                localVarQueryParameter['balance_neq'] = balanceNeq;
            }

            if (balanceGt !== undefined) {
                localVarQueryParameter['balance_gt'] = balanceGt;
            }

            if (balanceLt !== undefined) {
                localVarQueryParameter['balance_lt'] = balanceLt;
            }

            if (balanceGte !== undefined) {
                localVarQueryParameter['balance_gte'] = balanceGte;
            }

            if (balanceLte !== undefined) {
                localVarQueryParameter['balance_lte'] = balanceLte;
            }

            if (balanceCurrencyEq) {
                localVarQueryParameter['balance_currency_eq'] = balanceCurrencyEq;
            }

            if (balanceCurrencyNeq) {
                localVarQueryParameter['balance_currency_neq'] = balanceCurrencyNeq;
            }

            if (isAdminEq !== undefined) {
                localVarQueryParameter['is_admin_eq'] = isAdminEq;
            }

            if (isAdminNeq !== undefined) {
                localVarQueryParameter['is_admin_neq'] = isAdminNeq;
            }

            if (isBannedEq !== undefined) {
                localVarQueryParameter['is_banned_eq'] = isBannedEq;
            }

            if (isBannedNeq !== undefined) {
                localVarQueryParameter['is_banned_neq'] = isBannedNeq;
            }

            if (createdAtEq) {
                localVarQueryParameter['created_at_eq'] = createdAtEq;
            }

            if (createdAtNeq) {
                localVarQueryParameter['created_at_neq'] = createdAtNeq;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString() :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString() :
                    createdAtLt;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (lastAccessAtEq) {
                localVarQueryParameter['last_access_at_eq'] = lastAccessAtEq;
            }

            if (lastAccessAtNeq) {
                localVarQueryParameter['last_access_at_neq'] = lastAccessAtNeq;
            }

            if (lastAccessAtGt !== undefined) {
                localVarQueryParameter['last_access_at_gt'] = (lastAccessAtGt as any instanceof Date) ?
                    (lastAccessAtGt as any).toISOString() :
                    lastAccessAtGt;
            }

            if (lastAccessAtLt !== undefined) {
                localVarQueryParameter['last_access_at_lt'] = (lastAccessAtLt as any instanceof Date) ?
                    (lastAccessAtLt as any).toISOString() :
                    lastAccessAtLt;
            }

            if (lastAccessAtGte !== undefined) {
                localVarQueryParameter['last_access_at_gte'] = (lastAccessAtGte as any instanceof Date) ?
                    (lastAccessAtGte as any).toISOString() :
                    lastAccessAtGte;
            }

            if (lastAccessAtLte !== undefined) {
                localVarQueryParameter['last_access_at_lte'] = (lastAccessAtLte as any instanceof Date) ?
                    (lastAccessAtLte as any).toISOString() :
                    lastAccessAtLte;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function is responsible for handling login requests. When a user attempts to access the login route, they are redirected to the frontend base URL specified in the application\'s configuration (command-line arguments or environment variables).  
         * @summary Handles the login route by redirecting the user to the frontend.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogin: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function manages user logout by initiating an OIDC provider-initiated logout and then redirecting the user to the frontend base URL.
         * @summary Handles the logout process by initiating a logout request with the OIDC provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function checks if a user is authenticated using the optional `User`. If the user is logged in, their information (ID, username, email, etc...) is returned as a JSON response. If not logged in, it returns a `204 No Content` response, indicating the user is not authenticated.
         * @summary Handles the `/me` route, returning the current user\'s information if authenticated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the user to retrieve.  - **Response Codes**:   - `200 OK`: The user was successfully retrieved.   - `404 Not Found`: The user doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the user is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a user by its unique identifier.
         * @param {string} id The database ID of the user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns an error if the user doesn\'t exist, if there is a validation issue, or if a database.
         * @summary Edit an existing user by ID.
         * @param {string} id user database id to edit user for
         * @param {EditUserRequest} editUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUser(id: string, editUserRequest: EditUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUser(id, editUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.editUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of user per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of users.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view others users
         * @summary Handles the request to retrieve a paginated list of users.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [emailEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [emailNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [usernameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [usernameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [balanceEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [balanceNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [balanceGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [balanceLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [balanceGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [balanceLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<CurrencyRequest>} [balanceCurrencyEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<CurrencyRequest>} [balanceCurrencyNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [isAdminEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [isAdminNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {boolean | null} [isBannedEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [isBannedNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<string>} [lastAccessAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [lastAccessAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [lastAccessAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [lastAccessAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [lastAccessAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [lastAccessAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<UserSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, emailEq?: Array<string>, emailNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, usernameEq?: Array<string>, usernameNeq?: Array<string>, balanceEq?: Array<string>, balanceNeq?: Array<string>, balanceGt?: string | null, balanceLt?: string | null, balanceGte?: string | null, balanceLte?: string | null, balanceCurrencyEq?: Array<CurrencyRequest>, balanceCurrencyNeq?: Array<CurrencyRequest>, isAdminEq?: boolean | null, isAdminNeq?: boolean | null, isBannedEq?: boolean | null, isBannedNeq?: boolean | null, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, lastAccessAtEq?: Array<string>, lastAccessAtNeq?: Array<string>, lastAccessAtGt?: string | null, lastAccessAtLt?: string | null, lastAccessAtGte?: string | null, lastAccessAtLte?: string | null, sort?: Array<UserSortEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(page, perPage, idEq, idNeq, emailEq, emailNeq, nameEq, nameNeq, usernameEq, usernameNeq, balanceEq, balanceNeq, balanceGt, balanceLt, balanceGte, balanceLte, balanceCurrencyEq, balanceCurrencyNeq, isAdminEq, isAdminNeq, isBannedEq, isBannedNeq, createdAtEq, createdAtNeq, createdAtGt, createdAtLt, createdAtGte, createdAtLte, lastAccessAtEq, lastAccessAtNeq, lastAccessAtGt, lastAccessAtLt, lastAccessAtGte, lastAccessAtLte, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function is responsible for handling login requests. When a user attempts to access the login route, they are redirected to the frontend base URL specified in the application\'s configuration (command-line arguments or environment variables).  
         * @summary Handles the login route by redirecting the user to the frontend.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogin(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogin(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function manages user logout by initiating an OIDC provider-initiated logout and then redirecting the user to the frontend base URL.
         * @summary Handles the logout process by initiating a logout request with the OIDC provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function checks if a user is authenticated using the optional `User`. If the user is logged in, their information (ID, username, email, etc...) is returned as a JSON response. If not logged in, it returns a `204 No Content` response, indicating the user is not authenticated.
         * @summary Handles the `/me` route, returning the current user\'s information if authenticated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the user to retrieve.  - **Response Codes**:   - `200 OK`: The user was successfully retrieved.   - `404 Not Found`: The user doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the user is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a user by its unique identifier.
         * @param {string} id The database ID of the user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Returns an error if the user doesn\'t exist, if there is a validation issue, or if a database.
         * @summary Edit an existing user by ID.
         * @param {UserApiEditUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(requestParameters: UserApiEditUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editUser(requestParameters.id, requestParameters.editUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of user per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of users.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view others users
         * @summary Handles the request to retrieve a paginated list of users.
         * @param {UserApiGetAllUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(requestParameters: UserApiGetAllUsersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserListResponse> {
            return localVarFp.getAllUsers(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.emailEq, requestParameters.emailNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.usernameEq, requestParameters.usernameNeq, requestParameters.balanceEq, requestParameters.balanceNeq, requestParameters.balanceGt, requestParameters.balanceLt, requestParameters.balanceGte, requestParameters.balanceLte, requestParameters.balanceCurrencyEq, requestParameters.balanceCurrencyNeq, requestParameters.isAdminEq, requestParameters.isAdminNeq, requestParameters.isBannedEq, requestParameters.isBannedNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.lastAccessAtEq, requestParameters.lastAccessAtNeq, requestParameters.lastAccessAtGt, requestParameters.lastAccessAtLt, requestParameters.lastAccessAtGte, requestParameters.lastAccessAtLte, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * This function is responsible for handling login requests. When a user attempts to access the login route, they are redirected to the frontend base URL specified in the application\'s configuration (command-line arguments or environment variables).  
         * @summary Handles the login route by redirecting the user to the frontend.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogin(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getLogin(options).then((request) => request(axios, basePath));
        },
        /**
         * This function manages user logout by initiating an OIDC provider-initiated logout and then redirecting the user to the frontend base URL.
         * @summary Handles the logout process by initiating a logout request with the OIDC provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * This function checks if a user is authenticated using the optional `User`. If the user is logged in, their information (ID, username, email, etc...) is returned as a JSON response. If not logged in, it returns a `204 No Content` response, indicating the user is not authenticated.
         * @summary Handles the `/me` route, returning the current user\'s information if authenticated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the user to retrieve.  - **Response Codes**:   - `200 OK`: The user was successfully retrieved.   - `404 Not Found`: The user doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the user is disabled, only an admin can retrieve it.
         * @summary Handles the request to fetch a user by its unique identifier.
         * @param {UserApiGetUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(requestParameters: UserApiGetUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.getUser(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for editUser operation in UserApi.
 * @export
 * @interface UserApiEditUserRequest
 */
export interface UserApiEditUserRequest {
    /**
     * user database id to edit user for
     * @type {string}
     * @memberof UserApiEditUser
     */
    readonly id: string

    /**
     * 
     * @type {EditUserRequest}
     * @memberof UserApiEditUser
     */
    readonly editUserRequest: EditUserRequest
}

/**
 * Request parameters for getAllUsers operation in UserApi.
 * @export
 * @interface UserApiGetAllUsersRequest
 */
export interface UserApiGetAllUsersRequest {
    /**
     * The page number to retrieve, starting from 0.
     * @type {number}
     * @memberof UserApiGetAllUsers
     */
    readonly page?: number | null

    /**
     * The number of items to return per page.
     * @type {number}
     * @memberof UserApiGetAllUsers
     */
    readonly perPage?: number | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly idEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly idNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly emailEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly emailNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly nameEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly nameNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly usernameEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly usernameNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceLte?: string | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceCurrencyEq?: Array<CurrencyRequest>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<CurrencyRequest>}
     * @memberof UserApiGetAllUsers
     */
    readonly balanceCurrencyNeq?: Array<CurrencyRequest>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof UserApiGetAllUsers
     */
    readonly isAdminEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof UserApiGetAllUsers
     */
    readonly isAdminNeq?: boolean | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof UserApiGetAllUsers
     */
    readonly isBannedEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof UserApiGetAllUsers
     */
    readonly isBannedNeq?: boolean | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly createdAtEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly createdAtNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly createdAtGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly createdAtLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly createdAtGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly createdAtLte?: string | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly lastAccessAtEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof UserApiGetAllUsers
     */
    readonly lastAccessAtNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly lastAccessAtGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly lastAccessAtLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly lastAccessAtGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof UserApiGetAllUsers
     */
    readonly lastAccessAtLte?: string | null

    /**
     * Used for sorting the output
     * @type {Array<UserSortEnum>}
     * @memberof UserApiGetAllUsers
     */
    readonly sort?: Array<UserSortEnum>
}

/**
 * Request parameters for getUser operation in UserApi.
 * @export
 * @interface UserApiGetUserRequest
 */
export interface UserApiGetUserRequest {
    /**
     * The database ID of the user to retrieve.
     * @type {string}
     * @memberof UserApiGetUser
     */
    readonly id: string
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Returns an error if the user doesn\'t exist, if there is a validation issue, or if a database.
     * @summary Edit an existing user by ID.
     * @param {UserApiEditUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public editUser(requestParameters: UserApiEditUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).editUser(requestParameters.id, requestParameters.editUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of user per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of users.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Only Admin can view others users
     * @summary Handles the request to retrieve a paginated list of users.
     * @param {UserApiGetAllUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAllUsers(requestParameters: UserApiGetAllUsersRequest = {}, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getAllUsers(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.emailEq, requestParameters.emailNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.usernameEq, requestParameters.usernameNeq, requestParameters.balanceEq, requestParameters.balanceNeq, requestParameters.balanceGt, requestParameters.balanceLt, requestParameters.balanceGte, requestParameters.balanceLte, requestParameters.balanceCurrencyEq, requestParameters.balanceCurrencyNeq, requestParameters.isAdminEq, requestParameters.isAdminNeq, requestParameters.isBannedEq, requestParameters.isBannedNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.lastAccessAtEq, requestParameters.lastAccessAtNeq, requestParameters.lastAccessAtGt, requestParameters.lastAccessAtLt, requestParameters.lastAccessAtGte, requestParameters.lastAccessAtLte, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function is responsible for handling login requests. When a user attempts to access the login route, they are redirected to the frontend base URL specified in the application\'s configuration (command-line arguments or environment variables).  
     * @summary Handles the login route by redirecting the user to the frontend.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getLogin(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getLogin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function manages user logout by initiating an OIDC provider-initiated logout and then redirecting the user to the frontend base URL.
     * @summary Handles the logout process by initiating a logout request with the OIDC provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getLogout(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function checks if a user is authenticated using the optional `User`. If the user is logged in, their information (ID, username, email, etc...) is returned as a JSON response. If not logged in, it returns a `204 No Content` response, indicating the user is not authenticated.
     * @summary Handles the `/me` route, returning the current user\'s information if authenticated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMe(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Path Parameters**:   `id` (UUID): The database ID of the user to retrieve.  - **Response Codes**:   - `200 OK`: The user was successfully retrieved.   - `404 Not Found`: The user doesn\'t exist.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the user is disabled, only an admin can retrieve it.
     * @summary Handles the request to fetch a user by its unique identifier.
     * @param {UserApiGetUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(requestParameters: UserApiGetUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WarehouseApi - axios parameter creator
 * @export
 */
export const WarehouseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The warehouse is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the warehouse in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The warehouse has been successfully disabled.
         * @summary Deletes a warehouse by its database ID.
         * @param {string} id Warehouse database id to delete warehouse for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWarehouse: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWarehouse', 'id', id)
            const localVarPath = `/warehouse/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The admin can change attributes such as the name, price, quantity, or image of the warehouse. If the warehouse image is changed, the old image will be deleted from S3 storage.  Returns an error if the warehouse doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing warehouse by ID in the store.
         * @param {string} id Warehouse database id to edit warehouse for
         * @param {EditWarehouseRequest} editWarehouseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWarehouse: async (id: string, editWarehouseRequest: EditWarehouseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editWarehouse', 'id', id)
            // verify required parameter 'editWarehouseRequest' is not null or undefined
            assertParamExists('editWarehouse', 'editWarehouseRequest', editWarehouseRequest)
            const localVarPath = `/warehouse/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editWarehouseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Parameters - `warehouse_id`: The unique identifier of the warehouse. - `pagination`: Query parameters for pagination, including `page` and `per_page`. - `filter`: Query parameters for filtering the products (e.g., by category, availability). - `sort`: Query parameters for sorting the products (e.g., by price or name). - `conn`: The database connection used to query the data.  # Returns - `200 OK`: A paginated list of products for the warehouse, including the current page and total pages. - `500 Internal Server Error`: An internal error occurs, possibly related to the database. - `400 Bad Request`: Invalid query parameters (pagination, filtering, or sorting).
         * @summary Fetches all warehouse products with pagination, filtering, and sorting options.
         * @param {string} warehouseId The database ID of the warehouse to retrieve.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [warehouseIdEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [warehouseIdNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [productIdEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [productIdNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [quantityEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [quantityNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<WarehouseProductSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWarehouseProducts: async (warehouseId: string, page?: number | null, perPage?: number | null, warehouseIdEq?: Array<string>, warehouseIdNeq?: Array<string>, productIdEq?: Array<string>, productIdNeq?: Array<string>, quantityEq?: Array<string>, quantityNeq?: Array<string>, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, sort?: Array<WarehouseProductSortEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'warehouseId' is not null or undefined
            assertParamExists('getAllWarehouseProducts', 'warehouseId', warehouseId)
            const localVarPath = `/warehouse/{warehouse_id}/product`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (warehouseIdEq) {
                localVarQueryParameter['warehouse_id_eq'] = warehouseIdEq;
            }

            if (warehouseIdNeq) {
                localVarQueryParameter['warehouse_id_neq'] = warehouseIdNeq;
            }

            if (productIdEq) {
                localVarQueryParameter['product_id_eq'] = productIdEq;
            }

            if (productIdNeq) {
                localVarQueryParameter['product_id_neq'] = productIdNeq;
            }

            if (quantityEq) {
                localVarQueryParameter['quantity_eq'] = quantityEq;
            }

            if (quantityNeq) {
                localVarQueryParameter['quantity_neq'] = quantityNeq;
            }

            if (createdAtEq) {
                localVarQueryParameter['created_at_eq'] = createdAtEq;
            }

            if (createdAtNeq) {
                localVarQueryParameter['created_at_neq'] = createdAtNeq;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString() :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString() :
                    createdAtLt;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of warehouses per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of warehouses.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see warehouses that are not hidden.
         * @summary Handles the request to retrieve a paginated list of warehouses.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<WarehouseSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWarehouses: async (page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, disabledEq?: boolean | null, disabledNeq?: boolean | null, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, sort?: Array<WarehouseSortEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/warehouse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (idEq) {
                localVarQueryParameter['id_eq'] = idEq;
            }

            if (idNeq) {
                localVarQueryParameter['id_neq'] = idNeq;
            }

            if (nameEq) {
                localVarQueryParameter['name_eq'] = nameEq;
            }

            if (nameNeq) {
                localVarQueryParameter['name_neq'] = nameNeq;
            }

            if (disabledEq !== undefined) {
                localVarQueryParameter['disabled_eq'] = disabledEq;
            }

            if (disabledNeq !== undefined) {
                localVarQueryParameter['disabled_neq'] = disabledNeq;
            }

            if (createdAtEq) {
                localVarQueryParameter['created_at_eq'] = createdAtEq;
            }

            if (createdAtNeq) {
                localVarQueryParameter['created_at_neq'] = createdAtNeq;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString() :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString() :
                    createdAtLt;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the warehouse to retrieve.  - **Response Codes**:   - `200 OK`: The warehouse was successfully retrieved.   - `400 Bad Request`: The request is improperly formatted.   - `404 Not Found`: The warehouse doesn\'t exist, or is disabled and the requester is not an admin.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the warehouse is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a warehouse by its unique identifier.
         * @param {string} id The database ID of the warehouse to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarehouse: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWarehouse', 'id', id)
            const localVarPath = `/warehouse/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows an administrator to fetch details about a product stored in a specified warehouse. If the warehouse or product does not exist, or if the warehouse is disabled and the requester lacks administrative privileges, an appropriate error response is returned.
         * @summary Retrieves a specific product from a warehouse.
         * @param {string} warehouseId The database ID of the warehouse to retrieve.
         * @param {string} productId The database ID of the product to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarehouseProduct: async (warehouseId: string, productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'warehouseId' is not null or undefined
            assertParamExists('getWarehouseProduct', 'warehouseId', warehouseId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getWarehouseProduct', 'productId', productId)
            const localVarPath = `/warehouse/{warehouse_id}/product/{product_id}`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)))
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication axum-oidc required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This function allows an admin to create a new warehouse by sending a POST request to the `/warehouse` endpoint. The new warehouse is validated and stored in the database. The image associated with the warehouse is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the warehouse\'s ID.  Path: `/warehouse`  - **Request Body:** Expects a `NewWarehouse` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new warehouse, returns the new warehouse\'s ID as a string.
         * @summary Handler for creating a new warehouse.
         * @param {NewWarehouseRequest} newWarehouseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewWarehouse: async (newWarehouseRequest: NewWarehouseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newWarehouseRequest' is not null or undefined
            assertParamExists('postNewWarehouse', 'newWarehouseRequest', newWarehouseRequest)
            const localVarPath = `/warehouse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newWarehouseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows an administrator to associate a product with a warehouse. It verifies the existence of both the warehouse and the product before proceeding with the creation. The function returns a `201 Created` response upon success, or an appropriate error response if the request is invalid or an internal error occurs.
         * @summary Handles the creation of a new warehouse product.
         * @param {string} warehouseId The database ID of the warehouse to retrieve.
         * @param {string} productId The database ID of the product to retrieve.
         * @param {NewWarehouseProductRequest} newWarehouseProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewWarehouseProduct: async (warehouseId: string, productId: string, newWarehouseProductRequest: NewWarehouseProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'warehouseId' is not null or undefined
            assertParamExists('postNewWarehouseProduct', 'warehouseId', warehouseId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('postNewWarehouseProduct', 'productId', productId)
            // verify required parameter 'newWarehouseProductRequest' is not null or undefined
            assertParamExists('postNewWarehouseProduct', 'newWarehouseProductRequest', newWarehouseProductRequest)
            const localVarPath = `/warehouse/{warehouse_id}/product/{product_id}`
                .replace(`{${"warehouse_id"}}`, encodeURIComponent(String(warehouseId)))
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newWarehouseProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WarehouseApi - functional programming interface
 * @export
 */
export const WarehouseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WarehouseApiAxiosParamCreator(configuration)
    return {
        /**
         * The warehouse is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the warehouse in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The warehouse has been successfully disabled.
         * @summary Deletes a warehouse by its database ID.
         * @param {string} id Warehouse database id to delete warehouse for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWarehouse(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWarehouse(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarehouseApi.deleteWarehouse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The admin can change attributes such as the name, price, quantity, or image of the warehouse. If the warehouse image is changed, the old image will be deleted from S3 storage.  Returns an error if the warehouse doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing warehouse by ID in the store.
         * @param {string} id Warehouse database id to edit warehouse for
         * @param {EditWarehouseRequest} editWarehouseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editWarehouse(id: string, editWarehouseRequest: EditWarehouseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editWarehouse(id, editWarehouseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarehouseApi.editWarehouse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * # Parameters - `warehouse_id`: The unique identifier of the warehouse. - `pagination`: Query parameters for pagination, including `page` and `per_page`. - `filter`: Query parameters for filtering the products (e.g., by category, availability). - `sort`: Query parameters for sorting the products (e.g., by price or name). - `conn`: The database connection used to query the data.  # Returns - `200 OK`: A paginated list of products for the warehouse, including the current page and total pages. - `500 Internal Server Error`: An internal error occurs, possibly related to the database. - `400 Bad Request`: Invalid query parameters (pagination, filtering, or sorting).
         * @summary Fetches all warehouse products with pagination, filtering, and sorting options.
         * @param {string} warehouseId The database ID of the warehouse to retrieve.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [warehouseIdEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [warehouseIdNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [productIdEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [productIdNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [quantityEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [quantityNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<WarehouseProductSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWarehouseProducts(warehouseId: string, page?: number | null, perPage?: number | null, warehouseIdEq?: Array<string>, warehouseIdNeq?: Array<string>, productIdEq?: Array<string>, productIdNeq?: Array<string>, quantityEq?: Array<string>, quantityNeq?: Array<string>, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, sort?: Array<WarehouseProductSortEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehouseProductsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWarehouseProducts(warehouseId, page, perPage, warehouseIdEq, warehouseIdNeq, productIdEq, productIdNeq, quantityEq, quantityNeq, createdAtEq, createdAtNeq, createdAtGt, createdAtLt, createdAtGte, createdAtLte, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarehouseApi.getAllWarehouseProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of warehouses per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of warehouses.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see warehouses that are not hidden.
         * @summary Handles the request to retrieve a paginated list of warehouses.
         * @param {number | null} [page] The page number to retrieve, starting from 0.
         * @param {number | null} [perPage] The number of items to return per page.
         * @param {Array<string>} [idEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [idNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {Array<string>} [nameEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [nameNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {boolean | null} [disabledEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
         * @param {boolean | null} [disabledNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
         * @param {Array<string>} [createdAtEq] Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
         * @param {Array<string>} [createdAtNeq] Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
         * @param {string | null} [createdAtGt] Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
         * @param {string | null} [createdAtLt] Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
         * @param {string | null} [createdAtGte] Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
         * @param {string | null} [createdAtLte] Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
         * @param {Array<WarehouseSortEnum>} [sort] Used for sorting the output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWarehouses(page?: number | null, perPage?: number | null, idEq?: Array<string>, idNeq?: Array<string>, nameEq?: Array<string>, nameNeq?: Array<string>, disabledEq?: boolean | null, disabledNeq?: boolean | null, createdAtEq?: Array<string>, createdAtNeq?: Array<string>, createdAtGt?: string | null, createdAtLt?: string | null, createdAtGte?: string | null, createdAtLte?: string | null, sort?: Array<WarehouseSortEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehouseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWarehouses(page, perPage, idEq, idNeq, nameEq, nameNeq, disabledEq, disabledNeq, createdAtEq, createdAtNeq, createdAtGt, createdAtLt, createdAtGte, createdAtLte, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarehouseApi.getAllWarehouses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the warehouse to retrieve.  - **Response Codes**:   - `200 OK`: The warehouse was successfully retrieved.   - `400 Bad Request`: The request is improperly formatted.   - `404 Not Found`: The warehouse doesn\'t exist, or is disabled and the requester is not an admin.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the warehouse is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a warehouse by its unique identifier.
         * @param {string} id The database ID of the warehouse to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWarehouse(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehouseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWarehouse(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarehouseApi.getWarehouse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows an administrator to fetch details about a product stored in a specified warehouse. If the warehouse or product does not exist, or if the warehouse is disabled and the requester lacks administrative privileges, an appropriate error response is returned.
         * @summary Retrieves a specific product from a warehouse.
         * @param {string} warehouseId The database ID of the warehouse to retrieve.
         * @param {string} productId The database ID of the product to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWarehouseProduct(warehouseId: string, productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehouseProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWarehouseProduct(warehouseId, productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarehouseApi.getWarehouseProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This function allows an admin to create a new warehouse by sending a POST request to the `/warehouse` endpoint. The new warehouse is validated and stored in the database. The image associated with the warehouse is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the warehouse\'s ID.  Path: `/warehouse`  - **Request Body:** Expects a `NewWarehouse` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new warehouse, returns the new warehouse\'s ID as a string.
         * @summary Handler for creating a new warehouse.
         * @param {NewWarehouseRequest} newWarehouseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNewWarehouse(newWarehouseRequest: NewWarehouseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNewWarehouse(newWarehouseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarehouseApi.postNewWarehouse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows an administrator to associate a product with a warehouse. It verifies the existence of both the warehouse and the product before proceeding with the creation. The function returns a `201 Created` response upon success, or an appropriate error response if the request is invalid or an internal error occurs.
         * @summary Handles the creation of a new warehouse product.
         * @param {string} warehouseId The database ID of the warehouse to retrieve.
         * @param {string} productId The database ID of the product to retrieve.
         * @param {NewWarehouseProductRequest} newWarehouseProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNewWarehouseProduct(warehouseId: string, productId: string, newWarehouseProductRequest: NewWarehouseProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNewWarehouseProduct(warehouseId, productId, newWarehouseProductRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarehouseApi.postNewWarehouseProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WarehouseApi - factory interface
 * @export
 */
export const WarehouseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WarehouseApiFp(configuration)
    return {
        /**
         * The warehouse is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the warehouse in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The warehouse has been successfully disabled.
         * @summary Deletes a warehouse by its database ID.
         * @param {WarehouseApiDeleteWarehouseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWarehouse(requestParameters: WarehouseApiDeleteWarehouseRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWarehouse(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * The admin can change attributes such as the name, price, quantity, or image of the warehouse. If the warehouse image is changed, the old image will be deleted from S3 storage.  Returns an error if the warehouse doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
         * @summary Edit an existing warehouse by ID in the store.
         * @param {WarehouseApiEditWarehouseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWarehouse(requestParameters: WarehouseApiEditWarehouseRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editWarehouse(requestParameters.id, requestParameters.editWarehouseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * # Parameters - `warehouse_id`: The unique identifier of the warehouse. - `pagination`: Query parameters for pagination, including `page` and `per_page`. - `filter`: Query parameters for filtering the products (e.g., by category, availability). - `sort`: Query parameters for sorting the products (e.g., by price or name). - `conn`: The database connection used to query the data.  # Returns - `200 OK`: A paginated list of products for the warehouse, including the current page and total pages. - `500 Internal Server Error`: An internal error occurs, possibly related to the database. - `400 Bad Request`: Invalid query parameters (pagination, filtering, or sorting).
         * @summary Fetches all warehouse products with pagination, filtering, and sorting options.
         * @param {WarehouseApiGetAllWarehouseProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWarehouseProducts(requestParameters: WarehouseApiGetAllWarehouseProductsRequest, options?: RawAxiosRequestConfig): AxiosPromise<WarehouseProductsListResponse> {
            return localVarFp.getAllWarehouseProducts(requestParameters.warehouseId, requestParameters.page, requestParameters.perPage, requestParameters.warehouseIdEq, requestParameters.warehouseIdNeq, requestParameters.productIdEq, requestParameters.productIdNeq, requestParameters.quantityEq, requestParameters.quantityNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of warehouses per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of warehouses.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see warehouses that are not hidden.
         * @summary Handles the request to retrieve a paginated list of warehouses.
         * @param {WarehouseApiGetAllWarehousesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWarehouses(requestParameters: WarehouseApiGetAllWarehousesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<WarehouseListResponse> {
            return localVarFp.getAllWarehouses(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * - **Path Parameters**:   `id` (UUID): The database ID of the warehouse to retrieve.  - **Response Codes**:   - `200 OK`: The warehouse was successfully retrieved.   - `400 Bad Request`: The request is improperly formatted.   - `404 Not Found`: The warehouse doesn\'t exist, or is disabled and the requester is not an admin.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the warehouse is hidden, only an admin can retrieve it.
         * @summary Handles the request to fetch a warehouse by its unique identifier.
         * @param {WarehouseApiGetWarehouseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarehouse(requestParameters: WarehouseApiGetWarehouseRequest, options?: RawAxiosRequestConfig): AxiosPromise<WarehouseResponse> {
            return localVarFp.getWarehouse(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows an administrator to fetch details about a product stored in a specified warehouse. If the warehouse or product does not exist, or if the warehouse is disabled and the requester lacks administrative privileges, an appropriate error response is returned.
         * @summary Retrieves a specific product from a warehouse.
         * @param {WarehouseApiGetWarehouseProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarehouseProduct(requestParameters: WarehouseApiGetWarehouseProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<WarehouseProductResponse> {
            return localVarFp.getWarehouseProduct(requestParameters.warehouseId, requestParameters.productId, options).then((request) => request(axios, basePath));
        },
        /**
         * This function allows an admin to create a new warehouse by sending a POST request to the `/warehouse` endpoint. The new warehouse is validated and stored in the database. The image associated with the warehouse is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the warehouse\'s ID.  Path: `/warehouse`  - **Request Body:** Expects a `NewWarehouse` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new warehouse, returns the new warehouse\'s ID as a string.
         * @summary Handler for creating a new warehouse.
         * @param {WarehouseApiPostNewWarehouseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewWarehouse(requestParameters: WarehouseApiPostNewWarehouseRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postNewWarehouse(requestParameters.newWarehouseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows an administrator to associate a product with a warehouse. It verifies the existence of both the warehouse and the product before proceeding with the creation. The function returns a `201 Created` response upon success, or an appropriate error response if the request is invalid or an internal error occurs.
         * @summary Handles the creation of a new warehouse product.
         * @param {WarehouseApiPostNewWarehouseProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewWarehouseProduct(requestParameters: WarehouseApiPostNewWarehouseProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postNewWarehouseProduct(requestParameters.warehouseId, requestParameters.productId, requestParameters.newWarehouseProductRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteWarehouse operation in WarehouseApi.
 * @export
 * @interface WarehouseApiDeleteWarehouseRequest
 */
export interface WarehouseApiDeleteWarehouseRequest {
    /**
     * Warehouse database id to delete warehouse for
     * @type {string}
     * @memberof WarehouseApiDeleteWarehouse
     */
    readonly id: string
}

/**
 * Request parameters for editWarehouse operation in WarehouseApi.
 * @export
 * @interface WarehouseApiEditWarehouseRequest
 */
export interface WarehouseApiEditWarehouseRequest {
    /**
     * Warehouse database id to edit warehouse for
     * @type {string}
     * @memberof WarehouseApiEditWarehouse
     */
    readonly id: string

    /**
     * 
     * @type {EditWarehouseRequest}
     * @memberof WarehouseApiEditWarehouse
     */
    readonly editWarehouseRequest: EditWarehouseRequest
}

/**
 * Request parameters for getAllWarehouseProducts operation in WarehouseApi.
 * @export
 * @interface WarehouseApiGetAllWarehouseProductsRequest
 */
export interface WarehouseApiGetAllWarehouseProductsRequest {
    /**
     * The database ID of the warehouse to retrieve.
     * @type {string}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly warehouseId: string

    /**
     * The page number to retrieve, starting from 0.
     * @type {number}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly page?: number | null

    /**
     * The number of items to return per page.
     * @type {number}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly perPage?: number | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly warehouseIdEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly warehouseIdNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly productIdEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly productIdNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly quantityEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly quantityNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly createdAtEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly createdAtNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly createdAtGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly createdAtLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly createdAtGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly createdAtLte?: string | null

    /**
     * Used for sorting the output
     * @type {Array<WarehouseProductSortEnum>}
     * @memberof WarehouseApiGetAllWarehouseProducts
     */
    readonly sort?: Array<WarehouseProductSortEnum>
}

/**
 * Request parameters for getAllWarehouses operation in WarehouseApi.
 * @export
 * @interface WarehouseApiGetAllWarehousesRequest
 */
export interface WarehouseApiGetAllWarehousesRequest {
    /**
     * The page number to retrieve, starting from 0.
     * @type {number}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly page?: number | null

    /**
     * The number of items to return per page.
     * @type {number}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly perPage?: number | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly idEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly idNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly nameEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly nameNeq?: Array<string>

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches the provided values.
     * @type {boolean}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly disabledEq?: boolean | null

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches the provided values.
     * @type {boolean}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly disabledNeq?: boolean | null

    /**
     * Field to filter for equality, allowing multiple values. This creates a condition where the column matches any of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly createdAtEq?: Array<string>

    /**
     * Field to filter for inequality, allowing multiple values. This excludes any results where the column matches one of the provided values.
     * @type {Array<string>}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly createdAtNeq?: Array<string>

    /**
     * Field to filter for #field_type greater than the specified value. Useful for range-based queries (e.g., prices above a threshold).
     * @type {string}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly createdAtGt?: string | null

    /**
     * Field to filter for #field_type less than the specified value. Useful for range-based queries (e.g., dates before a threshold).
     * @type {string}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly createdAtLt?: string | null

    /**
     * Field to filter for #field_type greater than or equal to the specified value. Similar to &#x60;gt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly createdAtGte?: string | null

    /**
     * Field to filter for #field_type less than or equal to the specified value. Similar to &#x60;lt&#x60;, but includes the boundary value in the results.
     * @type {string}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly createdAtLte?: string | null

    /**
     * Used for sorting the output
     * @type {Array<WarehouseSortEnum>}
     * @memberof WarehouseApiGetAllWarehouses
     */
    readonly sort?: Array<WarehouseSortEnum>
}

/**
 * Request parameters for getWarehouse operation in WarehouseApi.
 * @export
 * @interface WarehouseApiGetWarehouseRequest
 */
export interface WarehouseApiGetWarehouseRequest {
    /**
     * The database ID of the warehouse to retrieve.
     * @type {string}
     * @memberof WarehouseApiGetWarehouse
     */
    readonly id: string
}

/**
 * Request parameters for getWarehouseProduct operation in WarehouseApi.
 * @export
 * @interface WarehouseApiGetWarehouseProductRequest
 */
export interface WarehouseApiGetWarehouseProductRequest {
    /**
     * The database ID of the warehouse to retrieve.
     * @type {string}
     * @memberof WarehouseApiGetWarehouseProduct
     */
    readonly warehouseId: string

    /**
     * The database ID of the product to retrieve.
     * @type {string}
     * @memberof WarehouseApiGetWarehouseProduct
     */
    readonly productId: string
}

/**
 * Request parameters for postNewWarehouse operation in WarehouseApi.
 * @export
 * @interface WarehouseApiPostNewWarehouseRequest
 */
export interface WarehouseApiPostNewWarehouseRequest {
    /**
     * 
     * @type {NewWarehouseRequest}
     * @memberof WarehouseApiPostNewWarehouse
     */
    readonly newWarehouseRequest: NewWarehouseRequest
}

/**
 * Request parameters for postNewWarehouseProduct operation in WarehouseApi.
 * @export
 * @interface WarehouseApiPostNewWarehouseProductRequest
 */
export interface WarehouseApiPostNewWarehouseProductRequest {
    /**
     * The database ID of the warehouse to retrieve.
     * @type {string}
     * @memberof WarehouseApiPostNewWarehouseProduct
     */
    readonly warehouseId: string

    /**
     * The database ID of the product to retrieve.
     * @type {string}
     * @memberof WarehouseApiPostNewWarehouseProduct
     */
    readonly productId: string

    /**
     * 
     * @type {NewWarehouseProductRequest}
     * @memberof WarehouseApiPostNewWarehouseProduct
     */
    readonly newWarehouseProductRequest: NewWarehouseProductRequest
}

/**
 * WarehouseApi - object-oriented interface
 * @export
 * @class WarehouseApi
 * @extends {BaseAPI}
 */
export class WarehouseApi extends BaseAPI {
    /**
     * The warehouse is not fully removed but marked as disabled in the database. Only an admin can perform this action.  - **Path Parameters:**   - `id`: The unique ID of the warehouse in the database.  - **Responses:**   - `500`: Internal error, likely related to the database.   - `400`: The request format is invalid.   - `200`: The warehouse has been successfully disabled.
     * @summary Deletes a warehouse by its database ID.
     * @param {WarehouseApiDeleteWarehouseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseApi
     */
    public deleteWarehouse(requestParameters: WarehouseApiDeleteWarehouseRequest, options?: RawAxiosRequestConfig) {
        return WarehouseApiFp(this.configuration).deleteWarehouse(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The admin can change attributes such as the name, price, quantity, or image of the warehouse. If the warehouse image is changed, the old image will be deleted from S3 storage.  Returns an error if the warehouse doesn\'t exist, if there is a validation issue, or if a database or S3 operation fails.
     * @summary Edit an existing warehouse by ID in the store.
     * @param {WarehouseApiEditWarehouseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseApi
     */
    public editWarehouse(requestParameters: WarehouseApiEditWarehouseRequest, options?: RawAxiosRequestConfig) {
        return WarehouseApiFp(this.configuration).editWarehouse(requestParameters.id, requestParameters.editWarehouseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Parameters - `warehouse_id`: The unique identifier of the warehouse. - `pagination`: Query parameters for pagination, including `page` and `per_page`. - `filter`: Query parameters for filtering the products (e.g., by category, availability). - `sort`: Query parameters for sorting the products (e.g., by price or name). - `conn`: The database connection used to query the data.  # Returns - `200 OK`: A paginated list of products for the warehouse, including the current page and total pages. - `500 Internal Server Error`: An internal error occurs, possibly related to the database. - `400 Bad Request`: Invalid query parameters (pagination, filtering, or sorting).
     * @summary Fetches all warehouse products with pagination, filtering, and sorting options.
     * @param {WarehouseApiGetAllWarehouseProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseApi
     */
    public getAllWarehouseProducts(requestParameters: WarehouseApiGetAllWarehouseProductsRequest, options?: RawAxiosRequestConfig) {
        return WarehouseApiFp(this.configuration).getAllWarehouseProducts(requestParameters.warehouseId, requestParameters.page, requestParameters.perPage, requestParameters.warehouseIdEq, requestParameters.warehouseIdNeq, requestParameters.productIdEq, requestParameters.productIdNeq, requestParameters.quantityEq, requestParameters.quantityNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Query Parameters**:   - `page` (Optional, u64): The page index, default is 0.   - `per_page` (Optional, u64): The number of warehouses per page, default is 20.  - **Response Codes**:   - `200 OK`: Successfully retrieved a list of warehouses.   - `400 Bad Request`: The request is improperly formatted.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   Non-admin users will only see warehouses that are not hidden.
     * @summary Handles the request to retrieve a paginated list of warehouses.
     * @param {WarehouseApiGetAllWarehousesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseApi
     */
    public getAllWarehouses(requestParameters: WarehouseApiGetAllWarehousesRequest = {}, options?: RawAxiosRequestConfig) {
        return WarehouseApiFp(this.configuration).getAllWarehouses(requestParameters.page, requestParameters.perPage, requestParameters.idEq, requestParameters.idNeq, requestParameters.nameEq, requestParameters.nameNeq, requestParameters.disabledEq, requestParameters.disabledNeq, requestParameters.createdAtEq, requestParameters.createdAtNeq, requestParameters.createdAtGt, requestParameters.createdAtLt, requestParameters.createdAtGte, requestParameters.createdAtLte, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - **Path Parameters**:   `id` (UUID): The database ID of the warehouse to retrieve.  - **Response Codes**:   - `200 OK`: The warehouse was successfully retrieved.   - `400 Bad Request`: The request is improperly formatted.   - `404 Not Found`: The warehouse doesn\'t exist, or is disabled and the requester is not an admin.   - `500 Internal Server Error`: An internal error, most likely related to the database, occurred.  - **Permissions**:   If the warehouse is hidden, only an admin can retrieve it.
     * @summary Handles the request to fetch a warehouse by its unique identifier.
     * @param {WarehouseApiGetWarehouseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseApi
     */
    public getWarehouse(requestParameters: WarehouseApiGetWarehouseRequest, options?: RawAxiosRequestConfig) {
        return WarehouseApiFp(this.configuration).getWarehouse(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows an administrator to fetch details about a product stored in a specified warehouse. If the warehouse or product does not exist, or if the warehouse is disabled and the requester lacks administrative privileges, an appropriate error response is returned.
     * @summary Retrieves a specific product from a warehouse.
     * @param {WarehouseApiGetWarehouseProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseApi
     */
    public getWarehouseProduct(requestParameters: WarehouseApiGetWarehouseProductRequest, options?: RawAxiosRequestConfig) {
        return WarehouseApiFp(this.configuration).getWarehouseProduct(requestParameters.warehouseId, requestParameters.productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This function allows an admin to create a new warehouse by sending a POST request to the `/warehouse` endpoint. The new warehouse is validated and stored in the database. The image associated with the warehouse is checked in S3 storage.  - **Admin privileges** are required to access this route. - Returns a `201 Created` status upon successful creation along with the warehouse\'s ID.  Path: `/warehouse`  - **Request Body:** Expects a `NewWarehouse` JSON object. - **Responses:**     - 500: Internal server error (likely database related).     - 400: Bad request (invalid input data).     - 201: Successfully created a new warehouse, returns the new warehouse\'s ID as a string.
     * @summary Handler for creating a new warehouse.
     * @param {WarehouseApiPostNewWarehouseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseApi
     */
    public postNewWarehouse(requestParameters: WarehouseApiPostNewWarehouseRequest, options?: RawAxiosRequestConfig) {
        return WarehouseApiFp(this.configuration).postNewWarehouse(requestParameters.newWarehouseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows an administrator to associate a product with a warehouse. It verifies the existence of both the warehouse and the product before proceeding with the creation. The function returns a `201 Created` response upon success, or an appropriate error response if the request is invalid or an internal error occurs.
     * @summary Handles the creation of a new warehouse product.
     * @param {WarehouseApiPostNewWarehouseProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarehouseApi
     */
    public postNewWarehouseProduct(requestParameters: WarehouseApiPostNewWarehouseProductRequest, options?: RawAxiosRequestConfig) {
        return WarehouseApiFp(this.configuration).postNewWarehouseProduct(requestParameters.warehouseId, requestParameters.productId, requestParameters.newWarehouseProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



